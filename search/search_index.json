{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"None","text":"<p> \ud83d\udea7 PhysioKit is under active development </p> <p>Documentation: https://ambiqai.github.io/physiokit</p> <p>Source Code: https://github.com/AmbiqAI/physiokit</p> <p>Key Features:</p> <ul> <li>Handles a variety of physiological signals including ECG, PPG, RSP, and IMU.</li> <li>Geared towards real-time, noisy wearable sensor data.</li> <li>Provide advanced signal processing and feature extraction methods.</li> <li>Create synthetic signals for testing and benchmarking.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Installing PhysioKit can be done using <code>Poetry</code> or <code>pip</code>.</p> via Poetryvia pip <p><pre><code>$ poetry add physiokit\n\n---&gt; 100%\n</code></pre> </p> <p><pre><code>$ pip install physiokit\n\n---&gt; 100%\n</code></pre> </p>"},{"location":"#example","title":"Example","text":"<p>In this example, we will generate a synthetic ECG signal, clean it, and compute heart rate and HRV metrics.</p> <pre><code>import physiokit as pk\n\nsample_rate = 1000 # Hz\nheart_rate = 64 # BPM\nsignal_length = 8*sample_rate # 8 seconds\n\n# Generate synthetic ECG signal\necg, segs, fids = pk.ecg.synthesize(\n    signal_length=signal_length,\n    sample_rate=sample_rate,\n    heart_rate=heart_rate,\n    leads=1\n)\necg = ecg.squeeze()\n\n# Clean ECG signal\necg_clean = pk.ecg.clean(ecg, sample_rate=sample_rate)\n\n# Compute heart rate\nhr_bpm, _ = pk.ecg.compute_heart_rate(ecg_clean, sample_rate=sample_rate)\n\n# Extract R-peaks and RR-intervals\npeaks = pk.ecg.find_peaks(ecg_clean, sample_rate=sample_rate)\nrri = pk.ecg.compute_rr_intervals(peaks)\nmask = pk.ecg.filter_rr_intervals(rri, sample_rate=sample_rate)\n\n# Re-compute heart rate\nhr_bpm = 60 / (np.nanmean(rri[mask == 0]) / sample_rate)\n\n# Compute HRV metrics\nhrv_td = pk.hrv.compute_hrv_time(rri[mask == 0], sample_rate=sample_rate)\n\nbands = [(0.04, 0.15), (0.15, 0.4), (0.4, 0.5)]\nhrv_fd = pk.hrv.compute_hrv_frequency(\n    peaks[mask == 0],\n    rri[mask == 0],\n    bands=bands,\n    sample_rate=sample_rate\n)\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of BSD 3-Clause.</p>"},{"location":"api/ecg/","title":"Electrocardiogram (ECG)","text":"<p>Electrocardiography (ECG) is a non-invasive technique used to measure the electrical activity of the heart. ECG signals are often used to measure heart rate, heart rate variability (HRV), and respiratory rate. In PhysioKit, we provide a variety of routines for processing ECG signals.</p>"},{"location":"api/ecg/#physiokit.ecg.defines","title":"<code>physiokit.ecg.defines</code>","text":""},{"location":"api/ecg/#physiokit.ecg.defines.EcgFiducial","title":"<code>EcgFiducial</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>ECG fiducial labels</p> Source code in <code>physiokit/ecg/defines.py</code> <pre><code>class EcgFiducial(IntEnum):\n    \"\"\"ECG fiducial labels\"\"\"\n\n    p_wave = 8\n    q_wave = 9\n    q_trough = 10\n    r_peak = 11\n    rpr_peak = 12\n    s_trough = 13\n    j_point = 14\n    qt_segment = 15  # end\n    t_wave = 16  # end\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.defines.EcgSegment","title":"<code>EcgSegment</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>ECG Segment labels</p> Source code in <code>physiokit/ecg/defines.py</code> <pre><code>class EcgSegment(IntEnum):\n    \"\"\"ECG Segment labels\"\"\"\n\n    background = 0\n    p_wave = 1\n    qrs_complex = 2\n    t_wave = 3\n    u_wave = 4\n\n    pr_segment = 11  # End of P-wave to start of QRS\n    st_segment = 12  # End of QRS to start of T-wave\n    tp_segment = 13  # End of T-wave to start of P-wave\n    tp_overlap = 14  # T-on-P\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.clean","title":"<code>physiokit.ecg.clean</code>","text":""},{"location":"api/ecg/#physiokit.ecg.clean--ecg-cleaning-methods","title":"ECG cleaning methods.","text":""},{"location":"api/ecg/#physiokit.ecg.clean.clean","title":"<code>clean(data, lowcut=0.5, highcut=30, sample_rate=1000, order=3, axis=-1, forward_backward=True)</code>","text":"<p>Clean ECG signal by applying biquad filter.</p> <p>By default, a 3rd order Butterworth bandpass filter from 0.5 to 30 Hz is applied.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>ECG signal.</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Lower cutoff in Hz. Defaults to 0.5 Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>30</code> )         \u2013          <p>Upper cutoff in Hz. Defaults to 30 Hz.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>Filter order. Defaults to 3 (3rd order Butterworth filter).</p> </li> <li> <code>axis</code>             (<code>int</code>, default:                 <code>-1</code> )         \u2013          <p>Axis to apply against. Defaults to -1.</p> </li> <li> <code>forward_backward</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Apply filter forward and backward. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Cleaned ECG signal.</p> </li> </ul> Source code in <code>physiokit/ecg/clean.py</code> <pre><code>def clean(\n    data: npt.NDArray,\n    lowcut: float = 0.5,\n    highcut: float = 30,\n    sample_rate: float = 1000,\n    order: int = 3,\n    axis: int = -1,\n    forward_backward: bool = True,\n) -&gt; npt.NDArray:\n    \"\"\"Clean ECG signal by applying biquad filter.\n\n    By default, a 3rd order Butterworth bandpass filter from 0.5 to 30 Hz is applied.\n\n    Args:\n        data (npt.NDArray): ECG signal.\n        lowcut (float, optional): Lower cutoff in Hz. Defaults to 0.5 Hz.\n        highcut (float, optional): Upper cutoff in Hz. Defaults to 30 Hz.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        order (int, optional): Filter order. Defaults to 3 (3rd order Butterworth filter).\n        axis (int, optional): Axis to apply against. Defaults to -1.\n        forward_backward (bool, optional): Apply filter forward and backward. Defaults to True.\n\n    Returns:\n        npt.NDArray: Cleaned ECG signal.\n    \"\"\"\n\n    # Bandpass filter\n    ecg_clean = filter_signal(\n        data=data,\n        lowcut=lowcut,\n        highcut=highcut,\n        sample_rate=sample_rate,\n        order=order,\n        axis=axis,\n        forward_backward=forward_backward,\n    )\n\n    return ecg_clean\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.clean.square_filter_mask","title":"<code>square_filter_mask(rr_ints, lowcut=300, highcut=900)</code>","text":"<p>Mask out RR intervals that fall outside bounds.</p> <p>Parameters:</p> <ul> <li> <code>rr_ints</code>             (<code>NDArray</code>)         \u2013          <p>RR-interval list in ms.</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>300</code> )         \u2013          <p>Lower cutoff limit. Defaults to 300 ms.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>900</code> )         \u2013          <p>Upper cutoff limit. Defaults to 900 ms.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: RR rejection mask 0=accept, 1=reject.</p> </li> </ul> Source code in <code>physiokit/ecg/clean.py</code> <pre><code>def square_filter_mask(rr_ints: npt.NDArray, lowcut: float = 300, highcut: float = 900) -&gt; npt.NDArray:\n    \"\"\"Mask out RR intervals that fall outside bounds.\n\n    Args:\n        rr_ints (npt.NDArray): RR-interval list in ms.\n        lowcut (float, optional): Lower cutoff limit. Defaults to 300 ms.\n        highcut (float, optional): Upper cutoff limit. Defaults to 900 ms.\n\n    Returns:\n        npt.NDArray: RR rejection mask 0=accept, 1=reject.\n    \"\"\"\n    rr_mask = np.where((rr_ints &lt; lowcut) | (rr_ints &gt; highcut), 1, 0)\n    return rr_mask\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.metrics","title":"<code>physiokit.ecg.metrics</code>","text":""},{"location":"api/ecg/#physiokit.ecg.metrics.compute_heart_rate","title":"<code>compute_heart_rate(data, sample_rate=1000, method='peak', **kwargs)</code>","text":"<p>Compute heart rate from ECG signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>ECG signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'peak'</code> )         \u2013          <p>Method to compute heart rate. Defaults to 'peak'.</p> </li> <li> <code>**kwargs</code>             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>Keyword arguments to pass to method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>         \u2013          <p>tuple[float, float]: Heart rate in BPM and qos metric.</p> </li> </ul> Source code in <code>physiokit/ecg/metrics.py</code> <pre><code>def compute_heart_rate(\n    data: npt.NDArray, sample_rate: float = 1000, method: str = \"peak\", **kwargs: dict\n) -&gt; tuple[float, float]:\n    \"\"\"Compute heart rate from ECG signal.\n\n    Args:\n        data (array): ECG signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        method (str, optional): Method to compute heart rate. Defaults to 'peak'.\n        **kwargs (dict): Keyword arguments to pass to method.\n\n    Returns:\n        tuple[float, float]: Heart rate in BPM and qos metric.\n    \"\"\"\n    match method:\n        case \"peak\":\n            bpm, qos = compute_heart_rate_from_peaks(data=data, sample_rate=sample_rate, **kwargs)\n        case _:\n            raise NotImplementedError(f\"Heart rate computation method {method} not implemented.\")\n    # END MATH\n    return bpm, qos\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.metrics.compute_heart_rate_from_peaks","title":"<code>compute_heart_rate_from_peaks(data, sample_rate=1000, min_rr=0.3, max_rr=2.0, min_delta=0.3)</code>","text":"<p>Compute heart rate from peaks of ECG signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>ECG signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>         \u2013          <p>tuple[float, float]: Heart rate in BPM and qos metric.</p> </li> </ul> Source code in <code>physiokit/ecg/metrics.py</code> <pre><code>def compute_heart_rate_from_peaks(\n    data: npt.NDArray,\n    sample_rate: float = 1000,\n    min_rr: float = 0.3,\n    max_rr: float = 2.0,\n    min_delta: float | None = 0.3,\n) -&gt; tuple[float, float]:\n    \"\"\"Compute heart rate from peaks of ECG signal.\n\n    Args:\n        data (array): ECG signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n\n    Returns:\n        tuple[float, float]: Heart rate in BPM and qos metric.\n    \"\"\"\n    peaks = find_peaks(data=data, sample_rate=sample_rate)\n    rri = compute_rr_intervals(peaks=peaks)\n    rmask = filter_rr_intervals(rr_ints=rri, sample_rate=sample_rate, min_rr=min_rr, max_rr=max_rr, min_delta=min_delta)\n    bpm = 60 / (np.nanmean(rri[rmask == 0]) / sample_rate)\n    qos = rmask[rmask == 0].size / rmask.size\n    return bpm, qos\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.metrics.derive_respiratory_rate","title":"<code>derive_respiratory_rate(peaks, rri=None, sample_rate=1000, method='rifv', lowcut=0.1, highcut=1.0, order=3, threshold=0.85, interpolate_method='linear')</code>","text":"<p>Derive respiratory rate from ECG signal using given method.</p> <p>Parameters:</p> <ul> <li> <code>peaks</code>             (<code>array</code>)         \u2013          <p>QRS peaks of ECG signal.</p> </li> <li> <code>rri</code>             (<code>array</code>, default:                 <code>None</code> )         \u2013          <p>RR intervals. Defaults to None.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'rifv'</code> )         \u2013          <p>Method to compute respiratory rate. Defaults to 'riav'.</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>Lowcut frequency in Hz. Defaults to 0.1 Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Highcut frequency in Hz. Defaults to 1.0 Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>Order of filter. Defaults to 3.</p> </li> <li> <code>threshold</code>             (<code>float</code>, default:                 <code>0.85</code> )         \u2013          <p>Threshold for peak detection. Defaults to 0.85.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>         \u2013          <p>tuple[float, float]: Respiratory rate in BPM and qos metric.</p> </li> </ul> Source code in <code>physiokit/ecg/metrics.py</code> <pre><code>def derive_respiratory_rate(\n    peaks: npt.NDArray,\n    rri: npt.NDArray | None = None,\n    sample_rate: float = 1000,\n    method: Literal[\"rifv\"] = \"rifv\",\n    lowcut: float = 0.1,\n    highcut: float = 1.0,\n    order: int = 3,\n    threshold: float | None = 0.85,\n    interpolate_method: str = \"linear\",\n) -&gt; tuple[float, float]:\n    \"\"\"Derive respiratory rate from ECG signal using given method.\n\n    Args:\n        peaks (array): QRS peaks of ECG signal.\n        rri (array, optional): RR intervals. Defaults to None.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        method (str, optional): Method to compute respiratory rate. Defaults to 'riav'.\n        lowcut (float, optional): Lowcut frequency in Hz. Defaults to 0.1 Hz.\n        highcut (float, optional): Highcut frequency in Hz. Defaults to 1.0 Hz.\n        order (int, optional): Order of filter. Defaults to 3.\n        threshold (float, optional): Threshold for peak detection. Defaults to 0.85.\n\n    Returns:\n        tuple[float, float]: Respiratory rate in BPM and qos metric.\n    \"\"\"\n    if peaks.size &lt; 4:\n        raise ValueError(\"At least 4 peaks are required to compute respiratory rate\")\n\n    ts = np.arange(peaks[0], peaks[-1], 1)\n    match method:\n        case \"rifv\":\n            rsp = rri\n        case _:\n            raise ValueError(f\"Method {method} not implemented\")\n    rsp = scipy.interpolate.interp1d(peaks, rsp, kind=interpolate_method, fill_value=\"extrapolate\")(ts)\n    rsp = filter_signal(rsp, lowcut=lowcut, highcut=highcut, sample_rate=sample_rate, order=order)\n\n    freqs, rsp_sp = compute_fft(rsp, sample_rate=sample_rate)\n    l_idx = np.where(freqs &gt;= lowcut)[0][0]\n    r_idx = np.where(freqs &gt;= highcut)[0][0]\n    rsp_ps = 2 * np.abs(rsp_sp)\n    freqs = freqs[l_idx:r_idx]\n    rsp_ps = rsp_ps[l_idx:r_idx]\n\n    fft_pk_idx = np.argmax(rsp_ps)\n    if threshold is not None:\n        fft_pk_indices = np.where(rsp_ps &gt; threshold * rsp_ps[fft_pk_idx])[0]\n    else:\n        fft_pk_indices = [fft_pk_idx]\n\n    rsp_bpm_weights = rsp_ps[fft_pk_indices]\n    tgt_pwr = np.sum(rsp_bpm_weights)\n    rsp_bpm = 60 * np.sum(rsp_bpm_weights * freqs[fft_pk_indices]) / tgt_pwr\n    qos = tgt_pwr / np.mean(rsp_ps)\n\n    return rsp_bpm, qos\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.peaks","title":"<code>physiokit.ecg.peaks</code>","text":""},{"location":"api/ecg/#physiokit.ecg.peaks.compute_rr_intervals","title":"<code>compute_rr_intervals(peaks)</code>","text":"<p>Compute RR intervals from R peaks.</p> <p>Parameters:</p> <ul> <li> <code>peaks</code>             (<code>array</code>)         \u2013          <p>R peaks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: RR intervals.</p> </li> </ul> Source code in <code>physiokit/ecg/peaks.py</code> <pre><code>def compute_rr_intervals(\n    peaks: npt.NDArray,\n) -&gt; npt.NDArray:\n    \"\"\"Compute RR intervals from R peaks.\n\n    Args:\n        peaks (array): R peaks.\n\n    Returns:\n        npt.NDArray: RR intervals.\n    \"\"\"\n\n    rr_ints = np.diff(peaks)\n    if rr_ints.size == 0:\n        return rr_ints\n    rr_ints = np.hstack((rr_ints[0], rr_ints))\n    return rr_ints\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.peaks.filter_peaks","title":"<code>filter_peaks(peaks, sample_rate=1000, min_rr=0.3, max_rr=2.0, min_delta=0.3)</code>","text":"<p>Filter out peaks with RR intervals outside of normal range.</p> <p>Parameters:</p> <ul> <li> <code>peaks</code>             (<code>array</code>)         \u2013          <p>R peaks.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>min_rr</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum RR interval in seconds. Defaults to 0.3 s.</p> </li> <li> <code>max_rr</code>             (<code>float</code>, default:                 <code>2.0</code> )         \u2013          <p>Maximum RR interval in seconds. Defaults to 2.0 s.</p> </li> <li> <code>min_delta</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum RR interval delta. Defaults to 0.3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Filtered peaks.</p> </li> </ul> Source code in <code>physiokit/ecg/peaks.py</code> <pre><code>def filter_peaks(\n    peaks: npt.NDArray,\n    sample_rate: float = 1000,\n    min_rr: float = 0.3,\n    max_rr: float = 2.0,\n    min_delta: float | None = 0.3,\n) -&gt; npt.NDArray:\n    \"\"\"Filter out peaks with RR intervals outside of normal range.\n\n    Args:\n        peaks (array): R peaks.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        min_rr (float, optional): Minimum RR interval in seconds. Defaults to 0.3 s.\n        max_rr (float, optional): Maximum RR interval in seconds. Defaults to 2.0 s.\n        min_delta (float, optional): Minimum RR interval delta. Defaults to 0.3.\n\n    Returns:\n        npt.NDArray: Filtered peaks.\n    \"\"\"\n\n    # Capture RR intervals\n    rr_ints = np.diff(peaks)\n    rr_ints = np.hstack((rr_ints[0], rr_ints))\n\n    # Filter out peaks with RR intervals outside of normal range\n    rr_mask = np.where((rr_ints &lt; min_rr * sample_rate) | (rr_ints &gt; max_rr * sample_rate), 1, 0)\n\n    # Filter out peaks that deviate more than delta\n    if min_delta is not None:\n        rr_mask = quotient_filter_mask(rr_ints, mask=rr_mask, lowcut=1 - min_delta, highcut=1 + min_delta)\n    filt_peaks = peaks[np.where(rr_mask == 0)[0]]\n    return filt_peaks\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.peaks.filter_rr_intervals","title":"<code>filter_rr_intervals(rr_ints, sample_rate=1000, min_rr=0.3, max_rr=2.0, min_delta=0.3)</code>","text":"<p>Filter out peaks with RR intervals outside of normal range.</p> <p>Parameters:</p> <ul> <li> <code>rr_ints</code>             (<code>array</code>)         \u2013          <p>RR intervals.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>min_rr</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum RR interval in seconds. Defaults to 0.3 s.</p> </li> <li> <code>max_rr</code>             (<code>float</code>, default:                 <code>2.0</code> )         \u2013          <p>Maximum RR interval in seconds. Defaults to 2.0 s.</p> </li> <li> <code>min_delta</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum RR interval delta. Defaults to 0.3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: RR interval mask.</p> </li> </ul> Source code in <code>physiokit/ecg/peaks.py</code> <pre><code>def filter_rr_intervals(\n    rr_ints: npt.NDArray,\n    sample_rate: float = 1000,\n    min_rr: float = 0.3,\n    max_rr: float = 2.0,\n    min_delta: float | None = 0.3,\n) -&gt; npt.NDArray:\n    \"\"\"Filter out peaks with RR intervals outside of normal range.\n\n    Args:\n        rr_ints (array): RR intervals.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        min_rr (float, optional): Minimum RR interval in seconds. Defaults to 0.3 s.\n        max_rr (float, optional): Maximum RR interval in seconds. Defaults to 2.0 s.\n        min_delta (float, optional): Minimum RR interval delta. Defaults to 0.3.\n\n    Returns:\n        npt.NDArray: RR interval mask.\n    \"\"\"\n    if rr_ints.size == 0:\n        return np.array([])\n\n    # Filter out peaks with RR intervals outside of normal range\n    rr_mask = np.where((rr_ints &lt; min_rr * sample_rate) | (rr_ints &gt; max_rr * sample_rate), 1, 0)\n\n    # Filter out peaks that deviate more than delta\n    if min_delta is not None:\n        rr_mask = quotient_filter_mask(rr_ints, mask=rr_mask, lowcut=1 - min_delta, highcut=1 + min_delta)\n\n    return rr_mask\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.peaks.find_peaks","title":"<code>find_peaks(data, sample_rate=1000, qrs_window=0.1, avg_window=1.0, qrs_prom_weight=1.5, qrs_min_len_weight=0.4, qrs_min_delay=0.3)</code>","text":"<p>Find R peaks in ECG signal using QRS gradient method.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>ECG signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>qrs_window</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>Window size in seconds to compute QRS gradient. Defaults to 0.1 s.</p> </li> <li> <code>avg_window</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Window size in seconds to compute average gradient. Defaults to 1.0 s.</p> </li> <li> <code>qrs_prom_weight</code>             (<code>float</code>, default:                 <code>1.5</code> )         \u2013          <p>Weight to compute minimum QRS height. Defaults to 1.5.</p> </li> <li> <code>qrs_min_len_weight</code>             (<code>float</code>, default:                 <code>0.4</code> )         \u2013          <p>Weight to compute minimum QRS length. Defaults to 0.4.</p> </li> <li> <code>qrs_min_delay</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum delay between QRS complexes. Defaults to 0.3 s.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: R peaks.</p> </li> </ul> Source code in <code>physiokit/ecg/peaks.py</code> <pre><code>def find_peaks(\n    data: npt.NDArray,\n    sample_rate: float = 1000,\n    qrs_window: float = 0.1,\n    avg_window: float = 1.0,\n    qrs_prom_weight: float = 1.5,\n    qrs_min_len_weight: float = 0.4,\n    qrs_min_delay: float = 0.3,\n) -&gt; npt.NDArray:\n    \"\"\"Find R peaks in ECG signal using QRS gradient method.\n\n    Args:\n        data (array): ECG signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        qrs_window (float, optional): Window size in seconds to compute QRS gradient. Defaults to 0.1 s.\n        avg_window (float, optional): Window size in seconds to compute average gradient. Defaults to 1.0 s.\n        qrs_prom_weight (float, optional): Weight to compute minimum QRS height. Defaults to 1.5.\n        qrs_min_len_weight (float, optional): Weight to compute minimum QRS length. Defaults to 0.4.\n        qrs_min_delay (float, optional): Minimum delay between QRS complexes. Defaults to 0.3 s.\n\n    Returns:\n        npt.NDArray: R peaks.\n    \"\"\"\n\n    # Identify start and end of QRS complexes.\n    qrs = (\n        moving_gradient_filter(\n            data, sample_rate=sample_rate, sig_window=qrs_window, avg_window=avg_window, sig_prom_weight=qrs_prom_weight\n        )\n        &gt; 0\n    )\n\n    beg_qrs = np.where(np.logical_and(np.logical_not(qrs[0:-1]), qrs[1:]))[0]\n    end_qrs = np.where(np.logical_and(qrs[0:-1], np.logical_not(qrs[1:])))[0]\n    end_qrs = end_qrs[end_qrs &gt; beg_qrs[0]]\n\n    num_qrs = min(beg_qrs.size, end_qrs.size)\n    min_qrs_len = np.mean(end_qrs[:num_qrs] - beg_qrs[:num_qrs]) * qrs_min_len_weight\n    min_qrs_delay = int(np.rint(qrs_min_delay * sample_rate))\n\n    peaks = []\n    for i in range(num_qrs):\n        beg, end = beg_qrs[i], end_qrs[i]\n        peak = beg + np.argmax(data[beg:end])\n        qrs_len = end - beg\n        qrs_delay = peak - peaks[-1] if peaks else min_qrs_delay\n\n        # Enforce minimum delay between peaks\n        if qrs_delay &lt; min_qrs_delay or qrs_len &lt; min_qrs_len:\n            continue\n        peaks.append(peak)\n    # END FOR\n\n    return np.array(peaks, dtype=int)\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.segment","title":"<code>physiokit.ecg.segment</code>","text":""},{"location":"api/ecg/#physiokit.ecg.segment.apply_segmentation","title":"<code>apply_segmentation(data, sample_rate=1000)</code>","text":"<p>Apply segmentation to ECG signal.</p> Source code in <code>physiokit/ecg/segment.py</code> <pre><code>def apply_segmentation(\n    data: npt.NDArray,\n    sample_rate: float = 1000,\n    # lead: int|None = None\n) -&gt; npt.NDArray:\n    \"\"\"Apply segmentation to ECG signal.\"\"\"\n    segs = np.zeros(data.size, dtype=int)\n    segs[:] = EcgSegment.background\n\n    qrs_segs: list[tuple[int, int, int]] = []\n    p_segs: list[tuple[int, int, int]] = []\n    t_segs: list[tuple[int, int, int]] = []\n\n    # Identify QRS segments and peaks\n    # qrs = clean_ecg(data, sample_rate=sample_rate, lowcut=10.0, highcut=30.0)\n    qrs_segs = locate_qrs(data, sample_rate=sample_rate)\n    # Extract nominal RR interval, filter out R peaks (mark as noise)\n    # For each QRS segment, extract P wave and T wave\n    for qrs_seg in qrs_segs:\n        print(\"QRS\", qrs_seg)\n        segs[qrs_seg[0] : qrs_seg[2]] = EcgSegment.qrs_complex\n        # Extract P wave and T wave\n        print(\"P-wave\")\n        p_seg = locate_pwave_from_qrs_anchor(data, qrs_seg, sample_rate=sample_rate)\n        if p_seg:\n            segs[p_seg[0] : p_seg[2]] = EcgSegment.p_wave\n            p_segs.append(p_seg)\n        # END IF\n        print(\"T-wave\")\n        t_seg = locate_twave_from_qrs_anchor(data, qrs_seg, sample_rate=sample_rate)\n        if t_seg:\n            segs[t_seg[0] : t_seg[2]] = EcgSegment.t_wave\n            t_segs.append(t_seg)\n        # END IF\n    # END FOR\n    return segs\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.segment.find_pwave","title":"<code>find_pwave()</code>","text":"<p>Find P wave in ECG signal</p> Source code in <code>physiokit/ecg/segment.py</code> <pre><code>def find_pwave():\n    \"\"\"Find P wave in ECG signal\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.segment.find_qrs","title":"<code>find_qrs()</code>","text":"<p>Find QRS complex in ECG signal</p> Source code in <code>physiokit/ecg/segment.py</code> <pre><code>def find_qrs():\n    \"\"\"Find QRS complex in ECG signal\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.segment.find_twave","title":"<code>find_twave()</code>","text":"<p>Find T wave in ECG signal</p> Source code in <code>physiokit/ecg/segment.py</code> <pre><code>def find_twave():\n    \"\"\"Find T wave in ECG signal\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.segment.locate_pwave_from_qrs_anchor","title":"<code>locate_pwave_from_qrs_anchor(data, qrs_seg, sample_rate=1000, wave_window=0.1, avg_window=0.3, wave_prom_weight=1.0, wave_min_window=0.01)</code>","text":"<p>Locate P wave in ECG signal using QRS anchor method.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>ECG signal.</p> </li> <li> <code>qrs_seg</code>             (<code>tuple[int, int, int]</code>)         \u2013          <p>QRS segment.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>wave_window</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>Window size in seconds to compute wave gradient. Defaults to 0.1 s.</p> </li> <li> <code>avg_window</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Window size in seconds to compute average gradient. Defaults to 0.3 s.</p> </li> <li> <code>wave_prom_weight</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Weight to compute minimum wave height. Defaults to 1.0.</p> </li> <li> <code>wave_min_window</code>             (<code>float</code>, default:                 <code>0.01</code> )         \u2013          <p>Minimum wave length in seconds. Defaults to 0.05 s.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int, int] | None</code>         \u2013          <p>tuple[int, int, int] | None: Wave onset, peak, and offset.</p> </li> </ul> Source code in <code>physiokit/ecg/segment.py</code> <pre><code>def locate_pwave_from_qrs_anchor(\n    data: npt.NDArray,\n    qrs_seg: tuple[int, int, int],\n    sample_rate: float = 1000,\n    wave_window: float = 0.1,\n    avg_window: float = 0.3,\n    wave_prom_weight: float = 1.0,\n    wave_min_window: float = 0.01,\n) -&gt; tuple[int, int, int] | None:\n    \"\"\"Locate P wave in ECG signal using QRS anchor method.\n\n    Args:\n        data (array): ECG signal.\n        qrs_seg (tuple[int, int, int]): QRS segment.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        wave_window (float, optional): Window size in seconds to compute wave gradient. Defaults to 0.1 s.\n        avg_window (float, optional): Window size in seconds to compute average gradient. Defaults to 0.3 s.\n        wave_prom_weight (float, optional): Weight to compute minimum wave height. Defaults to 1.0.\n        wave_min_window (float, optional): Minimum wave length in seconds. Defaults to 0.05 s.\n\n    Returns:\n        tuple[int, int, int] | None: Wave onset, peak, and offset.\n    \"\"\"\n    # Grab window from end of QRS to 300 ms before (PQ interval)\n    pq_window = int(np.rint(0.3 * sample_rate))\n    # roi_offset = qrs_seg[2]\n    # roi_onset = max(0, roi_offset - pq_window)\n    roi_offset = qrs_seg[0]\n    roi_onset = max(0, roi_offset - pq_window)\n\n    roi = data[roi_onset:roi_offset].copy()\n\n    # Zero out QRS region\n    # qrs_offset = qrs_seg[0] - roi_onset\n    # roi[qrs_offset:] = roi[qrs_offset]\n\n    wave = _locate_wave_in_region(\n        roi,\n        sample_rate=sample_rate,\n        wave_window=wave_window,\n        avg_window=avg_window,\n        wave_prom_weight=wave_prom_weight,\n        wave_min_window=wave_min_window,\n        reverse=True,\n    )\n    if wave:\n        return (roi_onset + wave[0], roi_onset + wave[1], roi_onset + wave[2])\n    return None\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.segment.locate_qrs","title":"<code>locate_qrs(data, sample_rate=1000, qrs_window=0.1, avg_window=1.0, qrs_prom_weight=1.5, qrs_min_len_weight=0.4, qrs_min_delay=0.3)</code>","text":"<p>Find QRS segments in ECG signal using QRS gradient method.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>ECG signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>qrs_window</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>Window size in seconds to compute QRS gradient. Defaults to 0.1 s.</p> </li> <li> <code>avg_window</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Window size in seconds to compute average gradient. Defaults to 1.0 s.</p> </li> <li> <code>qrs_prom_weight</code>             (<code>float</code>, default:                 <code>1.5</code> )         \u2013          <p>Weight to compute minimum QRS height. Defaults to 1.5.</p> </li> <li> <code>qrs_min_len_weight</code>             (<code>float</code>, default:                 <code>0.4</code> )         \u2013          <p>Weight to compute minimum QRS length. Defaults to 0.4.</p> </li> <li> <code>qrs_min_delay</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum delay between QRS complexes. Defaults to 0.3 s.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[NDArray]</code>         \u2013          <p>tuple[npt.NDArray]: QRS segments</p> </li> </ul> Source code in <code>physiokit/ecg/segment.py</code> <pre><code>def locate_qrs(\n    data: npt.NDArray,\n    sample_rate: float = 1000,\n    qrs_window: float = 0.1,\n    avg_window: float = 1.0,\n    qrs_prom_weight: float = 1.5,\n    qrs_min_len_weight: float = 0.4,\n    qrs_min_delay: float = 0.3,\n) -&gt; tuple[npt.NDArray]:\n    \"\"\"Find QRS segments in ECG signal using QRS gradient method.\n\n    Args:\n        data (array): ECG signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        qrs_window (float, optional): Window size in seconds to compute QRS gradient. Defaults to 0.1 s.\n        avg_window (float, optional): Window size in seconds to compute average gradient. Defaults to 1.0 s.\n        qrs_prom_weight (float, optional): Weight to compute minimum QRS height. Defaults to 1.5.\n        qrs_min_len_weight (float, optional): Weight to compute minimum QRS length. Defaults to 0.4.\n        qrs_min_delay (float, optional): Minimum delay between QRS complexes. Defaults to 0.3 s.\n\n    Returns:\n        tuple[npt.NDArray]: QRS segments\n    \"\"\"\n\n    # Identify start and end of QRS complexes.\n    qrs = (\n        moving_gradient_filter(\n            data, sample_rate=sample_rate, sig_window=qrs_window, avg_window=avg_window, sig_prom_weight=qrs_prom_weight\n        )\n        &gt; 0\n    )\n    beg_qrs = np.where(np.logical_and(np.logical_not(qrs[0:-1]), qrs[1:]))[0]\n    end_qrs = np.where(np.logical_and(qrs[0:-1], np.logical_not(qrs[1:])))[0]\n    end_qrs = end_qrs[end_qrs &gt; beg_qrs[0]]\n\n    num_qrs = min(beg_qrs.size, end_qrs.size)\n    min_qrs_len = int(np.mean(end_qrs[:num_qrs] - beg_qrs[:num_qrs]) * qrs_min_len_weight)\n    min_qrs_delay = int(np.rint(qrs_min_delay * sample_rate))\n\n    peaks: list[tuple(int, int, int)] = []\n    for i in range(num_qrs):\n        beg, end = beg_qrs[i], end_qrs[i]\n        peak = beg + np.argmax(data[beg:end])\n        qrs_len = int(end - beg)\n        qrs_delay = peak - peaks[-1][1] if peaks else min_qrs_delay\n\n        # Enforce minimum delay between peaks\n        if qrs_delay &lt; min_qrs_delay or qrs_len &lt; min_qrs_len:\n            continue\n        peaks.append((beg, peak, end))\n    # END FOR\n\n    return np.array(peaks, dtype=int)\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.segment.locate_twave_from_qrs_anchor","title":"<code>locate_twave_from_qrs_anchor(data, qrs_seg, sample_rate=1000, wave_window=0.3, avg_window=0.4, wave_prom_weight=1.0, wave_min_window=0.1)</code>","text":"<p>Locate T wave in ECG signal using QRS anchor method.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>ECG signal.</p> </li> <li> <code>qrs_seg</code>             (<code>tuple[int, int, int]</code>)         \u2013          <p>QRS segment.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>wave_window</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Window size in seconds to compute wave gradient. Defaults to 0.3 s.</p> </li> <li> <code>avg_window</code>             (<code>float</code>, default:                 <code>0.4</code> )         \u2013          <p>Window size in seconds to compute average gradient. Defaults to 0.6 s.</p> </li> <li> <code>wave_prom_weight</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Weight to compute minimum wave height. Defaults to 1.0.</p> </li> <li> <code>wave_min_window</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>Minimum wave length in seconds. Defaults to 0.1 s.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int, int] | None</code>         \u2013          <p>tuple[int, int, int] | None: Wave onset, peak, and offset.</p> </li> </ul> Source code in <code>physiokit/ecg/segment.py</code> <pre><code>def locate_twave_from_qrs_anchor(\n    data: npt.NDArray,\n    qrs_seg: tuple[int, int, int],\n    sample_rate: float = 1000,\n    wave_window: float = 0.3,\n    avg_window: float = 0.4,\n    wave_prom_weight: float = 1.0,\n    wave_min_window: float = 0.1,\n) -&gt; tuple[int, int, int] | None:\n    \"\"\"Locate T wave in ECG signal using QRS anchor method.\n\n    Args:\n        data (array): ECG signal.\n        qrs_seg (tuple[int, int, int]): QRS segment.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        wave_window (float, optional): Window size in seconds to compute wave gradient. Defaults to 0.3 s.\n        avg_window (float, optional): Window size in seconds to compute average gradient. Defaults to 0.6 s.\n        wave_prom_weight (float, optional): Weight to compute minimum wave height. Defaults to 1.0.\n        wave_min_window (float, optional): Minimum wave length in seconds. Defaults to 0.1 s.\n\n    Returns:\n        tuple[int, int, int] | None: Wave onset, peak, and offset.\n    \"\"\"\n\n    # Grab window from end of QRS to 400 ms after (ST interval)\n    st_window = int(np.rint(0.4 * sample_rate))\n    roi_onset = qrs_seg[2]\n    roi_offset = min(roi_onset + st_window, data.size)\n    # roi_onset = qrs_seg[0]\n    # roi_offset = min(roi_onset + qt_window, data.size)\n    roi = data[roi_onset:roi_offset].copy()\n\n    # Zero out QRS region\n    # qrs_offset = qrs_seg[2] - roi_onset\n    # roi[:qrs_offset] = roi[qrs_offset]\n\n    wave = _locate_wave_in_region(\n        roi,\n        sample_rate=sample_rate,\n        wave_window=wave_window,\n        avg_window=avg_window,\n        wave_prom_weight=wave_prom_weight,\n        wave_min_window=wave_min_window,\n    )\n    if wave:\n        return (roi_onset + wave[0], roi_onset + wave[1], roi_onset + wave[2])\n    return None\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.synthesize","title":"<code>physiokit.ecg.synthesize</code>","text":""},{"location":"api/ecg/#physiokit.ecg.synthesize.simulate_daubechies","title":"<code>simulate_daubechies(signal_length=10000, sample_rate=1000, heart_rate=70)</code>","text":"<p>Generate an artificial (synthetic) ECG signal of a given duration and sampling rate.</p> <p>It uses a 'Daubechies' wavelet that roughly approximates a single cardiac cycle. This function is based on <code>this script &lt;https://github.com/diarmaidocualain/ecg_simulation&gt;</code>_.</p> <p>Parameters:</p> <ul> <li> <code>signal_length</code>             (<code>int</code>, default:                 <code>10000</code> )         \u2013          <p>Length of the ECG signal. Defaults to 10000.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>ECG sampling frequency. Defaults to 1000.</p> </li> <li> <code>heart_rate</code>             (<code>float</code>, default:                 <code>70</code> )         \u2013          <p>Heart rate in BPM. Defaults to 70.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Synthetic ECG signal</p> </li> </ul> Source code in <code>physiokit/ecg/synthesize.py</code> <pre><code>def simulate_daubechies(signal_length: int = 10000, sample_rate: float = 1000, heart_rate: float = 70) -&gt; npt.NDArray:\n    \"\"\"Generate an artificial (synthetic) ECG signal of a given duration and sampling rate.\n\n    It uses a 'Daubechies' wavelet that roughly approximates a single cardiac cycle.\n    This function is based on `this script &lt;https://github.com/diarmaidocualain/ecg_simulation&gt;`_.\n\n    Args:\n        signal_length (int, optional): Length of the ECG signal. Defaults to 10000.\n        sample_rate (float, optional): ECG sampling frequency. Defaults to 1000.\n        heart_rate (float, optional): Heart rate in BPM. Defaults to 70.\n\n    Returns:\n        npt.NDArray: Synthetic ECG signal\n\n    \"\"\"\n    duration = signal_length / sample_rate\n\n    # The \"Daubechies\" wavelet is a rough approximation to a real, single, cardiac cycle\n    cardiac = scipy.signal.daub(10)\n\n    # Add the gap after the pqrst when the heart is resting.\n    cardiac = np.concatenate([cardiac, np.zeros(10)])\n\n    # Caculate the number of beats in capture time period\n    num_heart_beats = int(duration * heart_rate / 60)\n\n    # Concatenate together the number of heart beats needed\n    ecg = np.tile(cardiac, num_heart_beats)\n\n    # Change amplitude\n    ecg = ecg * 10\n\n    # Resample\n    ecg = scipy.ndimage.zoom(ecg, signal_length / len(ecg))\n\n    ecg = ecg[:signal_length]\n\n    return ecg\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.synthesize.simulate_ecgsyn","title":"<code>simulate_ecgsyn(signal_length=10000, sample_rate=256, leads=12, heart_rate=60, hr_std=1, lfhfratio=0.5, sfint=512, ti=(-70, -15, 0, 15, 100), ai=(1.2, -5, 30, -7.5, 0.75), bi=(0.25, 0.1, 0.1, 0.1, 0.4), gamma=None)</code>","text":"<p>Simulate ECG using the ECGSYN algorithm.</p> <p>This function is a python translation of the matlab script by <code>McSharry &amp; Clifford (2013) &lt;https://physionet.org/content/ecgsyn&gt;</code>_.</p> <p>Parameters:</p> <ul> <li> <code>signal_length</code>             (<code>int</code>, default:                 <code>10000</code> )         \u2013          <p>Length of the ECG signal. Defaults to 10000.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>256</code> )         \u2013          <p>ECG sampling frequency. Defaults to 256.</p> </li> <li> <code>heart_rate</code>             (<code>float</code>, default:                 <code>60</code> )         \u2013          <p>Mean heart rate. Defaults to 60.</p> </li> <li> <code>hr_std</code>             (<code>float</code>, default:                 <code>1</code> )         \u2013          <p>Heart rate standard deviation. Defaults to 1.</p> </li> <li> <code>lfhfratio</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Low frequency high frequency ratio. Defaults to 0.5.</p> </li> <li> <code>sfint</code>             (<code>float</code>, default:                 <code>512</code> )         \u2013          <p>Internal sampling frequency. Defaults to 512.</p> </li> <li> <code>ti</code>             (<code>tuple[int]</code>, default:                 <code>(-70, -15, 0, 15, 100)</code> )         \u2013          <p>Time parameters. Defaults to (-70, -15, 0, 15, 100).</p> </li> <li> <code>ai</code>             (<code>tuple[float]</code>, default:                 <code>(1.2, -5, 30, -7.5, 0.75)</code> )         \u2013          <p>Amplitude parameters. Defaults to (1.2, -5, 30, -7.5, 0.75).</p> </li> <li> <code>bi</code>             (<code>tuple[float]</code>, default:                 <code>(0.25, 0.1, 0.1, 0.1, 0.4)</code> )         \u2013          <p>Width parameters. Defaults to (0.25, 0.1, 0.1, 0.1, 0.4).</p> </li> <li> <code>gamma</code>             (<code>NDArray | None</code>, default:                 <code>None</code> )         \u2013          <p>Lead modification matrix. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>tuple[list[npt.NDArray], list[npt.NDArray]]: ECG signals and results</p> </li> </ul> Source code in <code>physiokit/ecg/synthesize.py</code> <pre><code>def simulate_ecgsyn(\n    signal_length: int = 10000,\n    sample_rate: float = 256,\n    leads: int = 12,\n    heart_rate: float = 60,\n    hr_std: float = 1,\n    lfhfratio: float = 0.5,\n    sfint: float = 512,\n    ti: tuple[int] = (-70, -15, 0, 15, 100),\n    ai: tuple[float] = (1.2, -5, 30, -7.5, 0.75),\n    bi: tuple[float] = (0.25, 0.1, 0.1, 0.1, 0.4),\n    gamma: npt.NDArray | None = None,\n) -&gt; npt.NDArray:\n    \"\"\"Simulate ECG using the ECGSYN algorithm.\n\n    This function is a python translation of the matlab script by `McSharry &amp; Clifford (2013)\n    &lt;https://physionet.org/content/ecgsyn&gt;`_.\n\n    Args:\n        signal_length (int, optional): Length of the ECG signal. Defaults to 10000.\n        sample_rate (float, optional): ECG sampling frequency. Defaults to 256.\n        heart_rate (float, optional): Mean heart rate. Defaults to 60.\n        hr_std (float, optional): Heart rate standard deviation. Defaults to 1.\n        lfhfratio (float, optional): Low frequency high frequency ratio. Defaults to 0.5.\n        sfint (float, optional): Internal sampling frequency. Defaults to 512.\n        ti (tuple[int], optional): Time parameters. Defaults to (-70, -15, 0, 15, 100).\n        ai (tuple[float], optional): Amplitude parameters. Defaults to (1.2, -5, 30, -7.5, 0.75).\n        bi (tuple[float], optional): Width parameters. Defaults to (0.25, 0.1, 0.1, 0.1, 0.4).\n        gamma (npt.NDArray|None, optional): Lead modification matrix. Defaults to None.\n\n    Returns:\n        tuple[list[npt.NDArray], list[npt.NDArray]]: ECG signals and results\n\n    \"\"\"\n    if gamma is None:\n        gamma = np.array(\n            [\n                [1, 0.1, 1, 1.2, 1],\n                [2, 0.2, 0.2, 0.2, 3],\n                [1, -0.1, -0.8, -1.1, 2.5],\n                [-1, -0.05, -0.8, -0.5, -1.2],\n                [0.05, 0.05, 1, 1, 1],\n                [1, -0.05, -0.1, -0.1, 3],\n                [-0.5, 0.05, 0.2, 0.5, 1],\n                [0.05, 0.05, 1.3, 2.5, 2],\n                [1, 0.05, 1, 2, 1],\n                [1.2, 0.05, 1, 2, 2],\n                [1.5, 0.1, 0.8, 1, 2],\n                [1.8, 0.05, 0.5, 0.1, 2],\n            ]\n        )\n    # END IF\n\n    if not isinstance(ti, np.ndarray):\n        ti = np.array(ti)\n    if not isinstance(ai, np.ndarray):\n        ai = np.array(ai)\n    if not isinstance(bi, np.ndarray):\n        bi = np.array(bi)\n\n    duration = signal_length / sample_rate\n\n    # Number of beats\n    N = int(np.round(duration * (heart_rate / 60)))\n\n    ti = ti * np.pi / 180\n\n    # Adjust extrema parameters for mean heart rate\n    hrfact = np.sqrt(heart_rate / 60)\n    hrfact2 = np.sqrt(hrfact)\n    bi = hrfact * bi\n    ti = np.array([hrfact2, hrfact, 1, hrfact, hrfact2]) * ti\n\n    # Check that sfint is an integer multiple of sfecg\n    q = np.round(sfint / sample_rate)\n    qd = sfint / sample_rate\n    if q != qd:\n        raise ValueError(\n            \"Internal sampling frequency (sfint) must be an integer multiple of the ECG sampling frequency\"\n            \" (sfecg). Your current choices are: sfecg = \" + str(sample_rate) + \" and sfint = \" + str(sfint) + \".\"\n        )\n\n    # Define frequency parameters for rr process\n    # flo and fhi correspond to the Mayer waves and respiratory rate respectively\n    flo = 0.1\n    fhi = 0.25\n    flostd = 0.01\n    fhistd = 0.01\n\n    # Calculate time scales for rr and total output\n    sfrr = 1\n    trr = 1 / sfrr\n    rrmean = 60 / heart_rate\n    n = 2 ** (np.ceil(np.log2(N * rrmean / trr)))\n\n    rr0 = _ecg_simulate_rrprocess(flo, fhi, flostd, fhistd, lfhfratio, heart_rate, hr_std, sfrr, n)\n\n    # Upsample rr time series from 1 Hz to sfint Hz\n    desired_length = int(np.round(len(rr0) * sfint / 1))\n    rr = scipy.ndimage.zoom(rr0, desired_length / len(rr0))\n\n    # Make the rrn time series\n    dt = 1 / sfint\n    rrn = np.zeros(len(rr))\n    tecg = 0\n    i = 0\n    while i &lt; len(rr):\n        tecg += rr[i]\n        ip = int(np.round(tecg / dt))\n        rrn[i:ip] = rr[i]\n        i = ip\n    Nt = ip\n\n    # Integrate system using fourth order Runge-Kutta\n    x0 = np.array([1, 0, 0.04])\n\n    # tspan is a tuple of (min, max) which defines the lower and upper bound of t in ODE\n    # t_eval is the list of desired t points for ODE\n    # in Matlab, ode45 can accepts both tspan and t_eval in one argument\n    Tspan = [0, (Nt - 1) * dt]\n    t_eval = np.linspace(0, (Nt - 1) * dt, Nt)\n\n    # Initialize results containers\n    results = []\n    signals = []\n\n    # Multichannel modification (#625):\n    # --------------------------------------------------\n    # Loop over the twelve leads modifying ai in the loop to generate each lead's data\n    # Because these are all starting at the same position, it may make sense to grab a random\n    # segment within the series to simulate random phase and to forget the initial conditions\n\n    for i in range(leads):\n        gamma_row = gamma[i, :]\n        result = scipy.integrate.solve_ivp(\n            fun=functools.partial(_ecg_simulate_derivsecgsyn, rr=rrn, ti=ti, sfint=sfint, ai=gamma_row * ai, bi=bi),\n            t_span=Tspan,\n            y0=x0,\n            t_eval=t_eval,\n        )\n        results.append(result)\n        X0 = result.y  # get signal\n\n        # downsample to required sfecg\n        X = X0[:, np.arange(0, X0.shape[1], q).astype(int)]\n\n        # Scale signal to lie between -0.4 and 1.2 mV\n        z = X[2, :].copy()\n        zmin = np.min(z)\n        zmax = np.max(z)\n        zrange = zmax - zmin\n        z = (z - zmin) * 1.6 / zrange - 0.4\n\n        signals.append(z)\n    # END FOR\n\n    signals = np.hstack(signals)\n\n    signals = signals[:signal_length]\n    return signals\n</code></pre>"},{"location":"api/ecg/#physiokit.ecg.synthesize.synthesize","title":"<code>synthesize(signal_length=10000, sample_rate=1000, leads=12, heart_rate=60, preset=EcgPreset.SR, noise_multiplier=1.0, impedance=1.0, p_multiplier=1.0, t_multiplier=1.0, voltage_factor=300)</code>","text":"<p>Generate synthetic ECG signal via brisk method.</p> <p>Utilize pk.signal.noise methods to make more realistic.</p> Leads are indexed as follows <p>[\"I\", \"II\", \"III\", \"aVR\", \"aVL\", \"aVF\", \"V1\", \"V2\", \"V3\", \"V4\", \"V5\", \"V6\"]</p> <p>Parameters:</p> <ul> <li> <code>signal_length</code>             (<code>int</code>, default:                 <code>10000</code> )         \u2013          <p>Length of the ECG signal. Defaults to 10000.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>ECG sampling frequency. Defaults to 1000.</p> </li> <li> <code>leads</code>             (<code>int</code>, default:                 <code>12</code> )         \u2013          <p>Number of leads. Defaults to 12.</p> </li> <li> <code>heart_rate</code>             (<code>float</code>, default:                 <code>60</code> )         \u2013          <p>Mean heart rate. Defaults to 60.</p> </li> <li> <code>preset</code>             (<code>EcgPreset</code>, default:                 <code>SR</code> )         \u2013          <p>ECG preset. Defaults to EcgPreset.SR.</p> </li> <li> <code>noise_multiplier</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Noise multiplier. Defaults to 1.0.</p> </li> <li> <code>impedance</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Impedance. Defaults to 1.0.</p> </li> <li> <code>p_multiplier</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>P wave multiplier. Defaults to 1.0.</p> </li> <li> <code>t_multiplier</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>T wave multiplier. Defaults to 1.0.</p> </li> <li> <code>voltage_factor</code>             (<code>float</code>, default:                 <code>300</code> )         \u2013          <p>Voltage factor. Defaults to 300.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[NDArray, NDArray, NDArray]</code>         \u2013          <p>npt.NDArray: Synthetic ECG signals</p> </li> </ul> Source code in <code>physiokit/ecg/synthesize.py</code> <pre><code>def synthesize(\n    signal_length: int = 10000,\n    sample_rate: float = 1000,\n    leads: int = 12,\n    heart_rate: float = 60,\n    preset: EcgPreset = EcgPreset.SR,\n    noise_multiplier: float = 1.0,\n    impedance: float = 1.0,\n    p_multiplier: float = 1.0,\n    t_multiplier: float = 1.0,\n    voltage_factor: float = 300,\n) -&gt; tuple[npt.NDArray, npt.NDArray, npt.NDArray]:\n    \"\"\"Generate synthetic ECG signal via brisk method.\n\n    Utilize pk.signal.noise methods to make more realistic.\n\n    Leads are indexed as follows:\n        [\"I\", \"II\", \"III\", \"aVR\", \"aVL\", \"aVF\", \"V1\", \"V2\", \"V3\", \"V4\", \"V5\", \"V6\"]\n\n    Args:\n        signal_length (int, optional): Length of the ECG signal. Defaults to 10000.\n        sample_rate (float, optional): ECG sampling frequency. Defaults to 1000.\n        leads (int, optional): Number of leads. Defaults to 12.\n        heart_rate (float, optional): Mean heart rate. Defaults to 60.\n        preset (EcgPreset, optional): ECG preset. Defaults to EcgPreset.SR.\n        noise_multiplier (float, optional): Noise multiplier. Defaults to 1.0.\n        impedance (float, optional): Impedance. Defaults to 1.0.\n        p_multiplier (float, optional): P wave multiplier. Defaults to 1.0.\n        t_multiplier (float, optional): T wave multiplier. Defaults to 1.0.\n        voltage_factor (float, optional): Voltage factor. Defaults to 300.\n\n    Returns:\n        npt.NDArray: Synthetic ECG signals\n    \"\"\"\n\n    _, ecg, segs, fids, _ = simulate_brisk(\n        signal_length=signal_length,\n        sample_rate=sample_rate,\n        leads=leads,\n        heart_rate=heart_rate,\n        preset=preset,\n        noise_multiplier=noise_multiplier,\n        impedance=impedance,\n        p_multiplier=p_multiplier,\n        t_multiplier=t_multiplier,\n        voltage_factor=voltage_factor,\n    )\n\n    return ecg, segs, fids\n</code></pre>"},{"location":"api/hrv/","title":"Heart Rate Variability (HRV)","text":"<p>Heart rate variability (HRV) is the variation in the time interval between consecutive heartbeats. HRV is a measure of the autonomic nervous system (ANS) and is often used as a proxy for stress. HRV is also used to assess the risk of cardiovascular disease and sudden cardiac death.</p>"},{"location":"api/hrv/#physiokit.hrv.defines","title":"<code>physiokit.hrv.defines</code>","text":""},{"location":"api/hrv/#physiokit.hrv.defines.HrvFrequencyBandMetrics","title":"<code>HrvFrequencyBandMetrics</code>  <code>dataclass</code>","text":"<p>HRV Frequency domain metrics dataclass.</p> Source code in <code>physiokit/hrv/defines.py</code> <pre><code>@dataclass\nclass HrvFrequencyBandMetrics:\n    \"\"\"HRV Frequency domain metrics dataclass.\"\"\"\n\n    peak_frequency: float = 0  # Peak of frequency band in Hz\n    peak_power: float = 0  # Power of frequency band in ms^2\n    total_power: float = 0  # Total power in ms^2\n</code></pre>"},{"location":"api/hrv/#physiokit.hrv.defines.HrvFrequencyMetrics","title":"<code>HrvFrequencyMetrics</code>  <code>dataclass</code>","text":"<p>Frequency domain HRV metric dataclass.</p> Source code in <code>physiokit/hrv/defines.py</code> <pre><code>@dataclass\nclass HrvFrequencyMetrics:\n    \"\"\"Frequency domain HRV metric dataclass.\"\"\"\n\n    bands: list[HrvFrequencyBandMetrics] = field(default_factory=list)\n    total_power: float = 0  # Total power in ms^2\n</code></pre>"},{"location":"api/hrv/#physiokit.hrv.defines.HrvNonlinearMetrics","title":"<code>HrvNonlinearMetrics</code>  <code>dataclass</code>","text":"<p>Non-linear HRV metric dataclass.</p> Source code in <code>physiokit/hrv/defines.py</code> <pre><code>@dataclass\nclass HrvNonlinearMetrics:\n    \"\"\"Non-linear HRV metric dataclass.\"\"\"\n\n    sd1: float = 0  # Short-term variability\n    sd2: float = 0  # Long-term variability\n    sd1_sd2_ratio: float = 0  # Ratio of short-term to long-term variability\n</code></pre>"},{"location":"api/hrv/#physiokit.hrv.defines.HrvTimeMetrics","title":"<code>HrvTimeMetrics</code>  <code>dataclass</code>","text":"<p>Time domain HRV metric dataclass.</p> Source code in <code>physiokit/hrv/defines.py</code> <pre><code>@dataclass\nclass HrvTimeMetrics:\n    \"\"\"Time domain HRV metric dataclass.\"\"\"\n\n    # Deviation-based\n    mean_nn: float = 0  # Mean of normal intervals\n    sd_nn: float = 0  # St. Dev of normal intervals\n\n    # Difference-based\n    rms_sd: float = 0  # RMS of successive differences between normal intervals\n    sd_sd: float = 0  # St. Dev of successive differences between normal intervals\n\n    # Normalized\n    cv_nn: float = 0\n    cv_sd: float = 0\n\n    # Robust\n    median_nn: float = 0  # Median of normal intervals\n    mad_nn: float = 0  # Median absolute deviation of normal intervals\n    mcv_nn: float = 0  # Median coefficient of variation of normal intervals\n    iqr_nn: float = 0  # Interquartile range of normal intervals\n    prc20_nn: float = 0  # 20th percentile of normal intervals\n    prc80_nn: float = 0  # 80th percentile of normal intervals\n\n    # Extrema\n    nn50: int = 0  # Number of intervals &gt; 50 ms\n    nn20: int = 0  # Number of intervals &gt; 20 ms\n    pnn50: float = 0  # Percentage of intervals &gt; 50 ms\n    pnn20: float = 0  # Percentage of intervals &gt; 20 ms\n    min_nn: float = 0  # Minimum of normal intervals\n    max_nn: float = 0  # Maximum of normal intervals\n</code></pre>"},{"location":"api/hrv/#physiokit.hrv.time","title":"<code>physiokit.hrv.time</code>","text":""},{"location":"api/hrv/#physiokit.hrv.time.compute_hrv_time","title":"<code>compute_hrv_time(rr_intervals, sample_rate=1000)</code>","text":"<p>Compute time domain HRV metrics.</p> <p>Parameters:</p> <ul> <li> <code>rr_intervals</code>             (<code>NDArray</code>)         \u2013          <p>RR intervals.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate. Defaults to 1000 Hz.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HrvTimeMetrics</code> (            <code>HrvTimeMetrics</code> )        \u2013          <p>Time domain HRV metrics.</p> </li> </ul> Source code in <code>physiokit/hrv/time.py</code> <pre><code>def compute_hrv_time(\n    rr_intervals: npt.NDArray,\n    sample_rate: float = 1000,\n) -&gt; HrvTimeMetrics:\n    \"\"\"Compute time domain HRV metrics.\n\n    Args:\n        rr_intervals (npt.NDArray): RR intervals.\n        sample_rate (float, optional): Sampling rate. Defaults to 1000 Hz.\n\n    Returns:\n        HrvTimeMetrics: Time domain HRV metrics.\n    \"\"\"\n    rri_ms = rr_intervals / sample_rate * 1000\n\n    diff_rri_ms = np.diff(rri_ms)\n\n    # Deviation based\n    mean_nn = np.nanmean(rri_ms)\n    sd_nn = np.nanstd(rri_ms, ddof=1)\n\n    # Difference-based\n    rms_sd = np.sqrt(np.nanmean(diff_rri_ms**2))\n    sd_sd = np.nanstd(diff_rri_ms, ddof=1)\n\n    # Normalized\n    cv_nn = sd_nn / mean_nn\n    cv_sd = rms_sd / mean_nn\n\n    # Robust\n    median_nn = np.nanmedian(rri_ms)\n    mad_nn = 1.4826 * np.nanmedian(np.abs(rri_ms - median_nn))\n    mcv_nn = mad_nn / median_nn\n    iqr_nn = scipy.stats.iqr(rri_ms)\n    prc20_nn = np.nanpercentile(rri_ms, q=20)\n    prc80_nn = np.nanpercentile(rri_ms, q=80)\n\n    # Extrema\n    nn50 = np.sum(np.abs(diff_rri_ms) &gt; 50)\n    nn20 = np.sum(np.abs(diff_rri_ms) &gt; 20)\n    pnn50 = nn50 / (len(diff_rri_ms) + 1) * 100\n    pnn20 = nn20 / (len(diff_rri_ms) + 1) * 100\n    min_nn = np.nanmin(rri_ms)\n    max_nn = np.nanmax(rri_ms)\n\n    return HrvTimeMetrics(\n        mean_nn=mean_nn,\n        sd_nn=sd_nn,\n        rms_sd=rms_sd,\n        sd_sd=sd_sd,\n        cv_nn=cv_nn,\n        cv_sd=cv_sd,\n        median_nn=median_nn,\n        mad_nn=mad_nn,\n        mcv_nn=mcv_nn,\n        iqr_nn=iqr_nn,\n        prc20_nn=prc20_nn,\n        prc80_nn=prc80_nn,\n        nn50=nn50,\n        nn20=nn20,\n        pnn50=pnn50,\n        pnn20=pnn20,\n        min_nn=min_nn,\n        max_nn=max_nn,\n    )\n</code></pre>"},{"location":"api/hrv/#physiokit.hrv.frequency","title":"<code>physiokit.hrv.frequency</code>","text":""},{"location":"api/hrv/#physiokit.hrv.frequency.compute_hrv_frequency","title":"<code>compute_hrv_frequency(peaks, rri, bands, sample_rate=1000)</code>","text":"<p>Compute the frequency domain HRV features.</p> <p>Parameters:</p> <ul> <li> <code>peaks</code>             (<code>array</code>)         \u2013          <p>R peaks.</p> </li> <li> <code>rri</code>             (<code>array</code>)         \u2013          <p>RR intervals.</p> </li> <li> <code>bands</code>             (<code>list</code>)         \u2013          <p>List of frequency bands.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HrvFrequencyMetrics</code> (            <code>HrvFrequencyMetrics</code> )        \u2013          <p>Frequency domain HRV features.</p> </li> </ul> Source code in <code>physiokit/hrv/frequency.py</code> <pre><code>def compute_hrv_frequency(\n    peaks: npt.NDArray,\n    rri: npt.NDArray,\n    bands: list[tuple[float, float]],\n    sample_rate: float = 1000,\n) -&gt; HrvFrequencyMetrics:\n    \"\"\"Compute the frequency domain HRV features.\n\n    Args:\n        peaks (array): R peaks.\n        rri (array): RR intervals.\n        bands (list): List of frequency bands.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n\n    Returns:\n        HrvFrequencyMetrics: Frequency domain HRV features.\n    \"\"\"\n\n    # Interpolate to get evenly spaced samples\n    ts = np.arange(peaks[0], peaks[-1], 1)\n    rri_int = scipy.interpolate.interp1d(peaks, rri, kind=\"linear\")(ts)\n\n    # NOTE: Use bands to determine amount of zero padding for freq bins\n    fft_len = int(2 ** np.ceil(np.log2(max(ts.size, 32 * sample_rate))))\n\n    freqs, rri_fft = compute_fft(rri_int, sample_rate=sample_rate, fft_len=fft_len, window=\"blackman\", axis=-1)\n    rri_ps = 2 * np.abs(rri_fft)\n\n    metrics = HrvFrequencyMetrics()\n    for lowcut, highcut in bands:\n        l_idx = np.where(freqs &gt;= lowcut)[0][0]\n        r_idx = np.where(freqs &gt;= highcut)[0][0]\n        f_idx = rri_ps[l_idx:r_idx].argmax() + l_idx\n        metrics.bands.append(\n            HrvFrequencyBandMetrics(\n                peak_frequency=freqs[f_idx],\n                peak_power=rri_ps[f_idx],\n                total_power=rri_ps[l_idx:r_idx].sum(),\n            )\n        )\n    # END FOR\n    metrics.total_power = reduce(lambda x, y: x + y.total_power, metrics.bands, 0)\n    return metrics\n</code></pre>"},{"location":"api/imu/","title":"Inertial measurement unit (IMU)","text":"<p>Inertial measurement units (IMUs) are electronic devices that measure and report a body's specific force (acceleration and angular velocity) and orientation (roll, pitch, and yaw). IMU signals are often used to measure activity, posture, and gait. In PhysioKit, we provide a variety of routines for processing IMU signals.</p>"},{"location":"api/imu/#physiokit.imu.clean","title":"<code>physiokit.imu.clean</code>","text":""},{"location":"api/imu/#physiokit.imu.clean.clean","title":"<code>clean(data, lowcut=3, highcut=11, sample_rate=1000, order=3, axis=-1)</code>","text":"<p>Clean accelerometer signal using biquad filter.</p> <p>By default applies a 3rd order Butterworth filter between 0.5 and 4 Hz.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Accelerometer signal</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>3</code> )         \u2013          <p>Lower cutoff in Hz. Defaults to 3 Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>11</code> )         \u2013          <p>Upper cutoff in Hz. Defaults to 11 Hz.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sample rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>Filter order. Defaults to 3 (3rd order Butterworth filter).</p> </li> <li> <code>axis</code>             (<code>int</code>, default:                 <code>-1</code> )         \u2013          <p>Axis to apply against. Defaults to -1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Cleaned signal</p> </li> </ul> Source code in <code>physiokit/imu/clean.py</code> <pre><code>def clean(\n    data: npt.NDArray,\n    lowcut: float = 3,\n    highcut: float = 11,\n    sample_rate: float = 1000,\n    order: int = 3,\n    axis: int = -1,\n) -&gt; npt.NDArray:\n    \"\"\"Clean accelerometer signal using biquad filter.\n\n    By default applies a 3rd order Butterworth filter between 0.5 and 4 Hz.\n\n    Args:\n        data (npt.NDArray): Accelerometer signal\n        lowcut (float, optional): Lower cutoff in Hz. Defaults to 3 Hz.\n        highcut (float, optional): Upper cutoff in Hz. Defaults to 11 Hz.\n        sample_rate (float, optional): Sample rate in Hz. Defaults to 1000 Hz.\n        order (int, optional): Filter order. Defaults to 3 (3rd order Butterworth filter).\n        axis (int, optional): Axis to apply against. Defaults to -1.\n\n    Returns:\n        npt.NDArray: Cleaned signal\n    \"\"\"\n\n    return filter_signal(\n        data=data,\n        lowcut=lowcut,\n        highcut=highcut,\n        sample_rate=sample_rate,\n        order=order,\n        forward_backward=True,\n        axis=axis,\n    )\n</code></pre>"},{"location":"api/imu/#physiokit.imu.metrics","title":"<code>physiokit.imu.metrics</code>","text":""},{"location":"api/imu/#physiokit.imu.metrics.compute_counts","title":"<code>compute_counts(data, sample_rate=1000, epoch_len=10, min_thresh=4, max_thresh=128)</code>","text":"<p>Compute counts from raw accelerometer data.</p> <p>Reference: https://doi.org/10.1038/s41598-022-16003-x</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>2-D raw accelerometer data [ts x axis] in G.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>epoch_len</code>             (<code>int</code>, default:                 <code>10</code> )         \u2013          <p>Epoch length in seconds. Defaults to 10.</p> </li> <li> <code>min_thresh</code>             (<code>int</code>, default:                 <code>4</code> )         \u2013          <p>Minimum threshold. Defaults to 4.</p> </li> <li> <code>max_thresh</code>             (<code>int</code>, default:                 <code>128</code> )         \u2013          <p>Maximum threshold. Defaults to 128.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: 2-D counts data [ts x axis] in counts.</p> </li> </ul> Source code in <code>physiokit/imu/metrics.py</code> <pre><code>def compute_counts(\n    data: npt.NDArray, sample_rate: float = 1000, epoch_len: int = 10, min_thresh: int = 4, max_thresh: int = 128\n) -&gt; npt.NDArray:\n    \"\"\"Compute counts from raw accelerometer data.\n\n    Reference: https://doi.org/10.1038/s41598-022-16003-x\n\n    Args:\n        data (npt.NDArray): 2-D raw accelerometer data [ts x axis] in G.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        epoch_len (int, optional): Epoch length in seconds. Defaults to 10.\n        min_thresh (int, optional): Minimum threshold. Defaults to 4.\n        max_thresh (int, optional): Maximum threshold. Defaults to 128.\n\n    Returns:\n        npt.NDArray: 2-D counts data [ts x axis] in counts.\n    \"\"\"\n\n    # 1. Resample to 30 Hz\n    data = resample_signal(data, sample_rate=sample_rate, target_rate=30, axis=0)\n\n    # 2. Bandpass filter\n    data = _count_bpf_filter(data)\n\n    # 3. Rectify, &amp; threshold\n    data = np.abs(data)\n    data[data &lt; min_thresh] = 0\n    data[data &gt; max_thresh] = max_thresh\n    data = np.floor(data)\n\n    # 4. Downsample to 10 Hz by taking moving average (n=3)\n    data = np.nanmean(data.reshape((-1, 3, data.shape[1])), axis=1)\n\n    # 5. Find counts by summing over epoch length\n    counts = np.zeros((data.shape[0] // (10 * epoch_len),) + data.shape[1:], dtype=int)\n    for i in range(0, counts.shape[0]):\n        counts[i] = np.sum(data[i * 10 * epoch_len : (i + 1) * 10 * epoch_len], axis=0)\n    # END FOR\n\n    return counts\n</code></pre>"},{"location":"api/imu/#physiokit.imu.metrics.compute_enmo","title":"<code>compute_enmo(x, y, z)</code>","text":"<p>Compute ENMO from x, y, and z accelerometer data.</p> <p>Reference: https://doi.org/10.1371/journal.pone.0142533</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (<code>NDArray</code>)         \u2013          <p>x-axis accelerometer data</p> </li> <li> <code>y</code>             (<code>NDArray</code>)         \u2013          <p>y-axis accelerometer data</p> </li> <li> <code>z</code>             (<code>NDArray</code>)         \u2013          <p>z-axis accelerometer data</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: ENMO data</p> </li> </ul> Source code in <code>physiokit/imu/metrics.py</code> <pre><code>def compute_enmo(x: npt.NDArray, y: npt.NDArray, z: npt.NDArray) -&gt; npt.NDArray:\n    \"\"\"Compute ENMO from x, y, and z accelerometer data.\n\n    Reference: https://doi.org/10.1371/journal.pone.0142533\n\n    Args:\n        x (npt.NDArray): x-axis accelerometer data\n        y (npt.NDArray): y-axis accelerometer data\n        z (npt.NDArray): z-axis accelerometer data\n\n    Returns:\n        npt.NDArray: ENMO data\n    \"\"\"\n    enmo = np.maximum(np.sqrt(x**2 + y**2 + z**2) - 1, 0)\n    return enmo\n</code></pre>"},{"location":"api/imu/#physiokit.imu.metrics.compute_tilt_angles","title":"<code>compute_tilt_angles(x, y, z, in_radians=True)</code>","text":"<p>Compute tilt angles from x, y, and z accelerometer data.</p> <p>Reference: https://doi.org/10.1371/journal.pone.0142533</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (<code>NDArray</code>)         \u2013          <p>x-axis accelerometer data</p> </li> <li> <code>y</code>             (<code>NDArray</code>)         \u2013          <p>y-axis accelerometer data</p> </li> <li> <code>z</code>             (<code>NDArray</code>)         \u2013          <p>z-axis accelerometer data</p> </li> <li> <code>in_radians</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, return angles in radians. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[NDArray, NDArray, NDArray]</code>         \u2013          <p>tuple[npt.NDArray, npt.NDArray, npt.NDArray]: Tilt angles in radians or degrees</p> </li> </ul> Source code in <code>physiokit/imu/metrics.py</code> <pre><code>def compute_tilt_angles(\n    x: npt.NDArray, y: npt.NDArray, z: npt.NDArray, in_radians: bool = True\n) -&gt; tuple[npt.NDArray, npt.NDArray, npt.NDArray]:\n    \"\"\"Compute tilt angles from x, y, and z accelerometer data.\n\n    Reference: https://doi.org/10.1371/journal.pone.0142533\n\n    Args:\n        x (npt.NDArray): x-axis accelerometer data\n        y (npt.NDArray): y-axis accelerometer data\n        z (npt.NDArray): z-axis accelerometer data\n        in_radians (bool, optional): If True, return angles in radians. Defaults to True.\n\n    Returns:\n        tuple[npt.NDArray, npt.NDArray, npt.NDArray]: Tilt angles in radians or degrees\n\n    \"\"\"\n    x2 = x**2\n    y2 = y**2\n    z2 = z**2\n    factor = 1 if in_radians else 180.0 / np.pi\n    angle_x = np.arctan2(x, np.sqrt(y2 + z2)) * factor\n    angle_y = np.arctan2(y, np.sqrt(x2 + z2)) * factor\n    angle_z = np.arctan2(z, np.sqrt(x2 + y2)) * factor\n    return angle_x, angle_y, angle_z\n</code></pre>"},{"location":"api/ppg/","title":"Photoplethysmography (PPG)","text":"<p>Photoplethysmography (PPG) is a non-invasive optical technique used to measure blood volume changes in the microvascular bed of tissue. PPG signals are often used to measure heart rate, heart rate variability (HRV), respiratory rate, and oxygen saturation (SpO2). In PhysioKit, we provide a variety of routines for processing PPG signals.</p>"},{"location":"api/ppg/#physiokit.ppg.clean","title":"<code>physiokit.ppg.clean</code>","text":""},{"location":"api/ppg/#physiokit.ppg.clean.clean","title":"<code>clean(data, lowcut=0.5, highcut=4, sample_rate=1000, order=3, axis=-1, forward_backward=True)</code>","text":"<p>Clean PPG signal using biquad filter.</p> <p>By default applies a 3rd order Butterworth filter between 0.5 and 4 Hz.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Lower cutoff in Hz. Defaults to 0.5 Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>4</code> )         \u2013          <p>Upper cutoff in Hz. Defaults to 4 Hz.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sample rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>Filter order. Defaults to 3 (3rd order Butterworth filter).</p> </li> <li> <code>axis</code>             (<code>int</code>, default:                 <code>-1</code> )         \u2013          <p>Axis to apply against. Defaults to -1.</p> </li> <li> <code>forward_backward</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Apply filter forward and backward. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Cleaned signal</p> </li> </ul> Source code in <code>physiokit/ppg/clean.py</code> <pre><code>def clean(\n    data: npt.NDArray,\n    lowcut: float = 0.5,\n    highcut: float = 4,\n    sample_rate: float = 1000,\n    order: int = 3,\n    axis: int = -1,\n    forward_backward: bool = True,\n) -&gt; npt.NDArray:\n    \"\"\"Clean PPG signal using biquad filter.\n\n    By default applies a 3rd order Butterworth filter between 0.5 and 4 Hz.\n\n    Args:\n        data (npt.NDArray): Signal\n        lowcut (float, optional): Lower cutoff in Hz. Defaults to 0.5 Hz.\n        highcut (float, optional): Upper cutoff in Hz. Defaults to 4 Hz.\n        sample_rate (float, optional): Sample rate in Hz. Defaults to 1000 Hz.\n        order (int, optional): Filter order. Defaults to 3 (3rd order Butterworth filter).\n        axis (int, optional): Axis to apply against. Defaults to -1.\n        forward_backward (bool, optional): Apply filter forward and backward. Defaults to True.\n\n    Returns:\n        npt.NDArray: Cleaned signal\n    \"\"\"\n\n    return filter_signal(\n        data=data,\n        lowcut=lowcut,\n        highcut=highcut,\n        sample_rate=sample_rate,\n        order=order,\n        axis=axis,\n        forward_backward=forward_backward,\n    )\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.metrics","title":"<code>physiokit.ppg.metrics</code>","text":""},{"location":"api/ppg/#physiokit.ppg.metrics.compute_heart_rate","title":"<code>compute_heart_rate(data, sample_rate=1000, method='fft', **kwargs)</code>","text":"<p>Compute heart rate in BPM from PPG signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>PPG signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'fft'</code> )         \u2013          <p>Method to compute heart rate. Defaults to 'fft'.</p> </li> <li> <code>**kwargs</code>             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>Keyword arguments to pass to method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>tuple[float, float]</code> )        \u2013          <p>Heart rate in BPM.</p> </li> </ul> Source code in <code>physiokit/ppg/metrics.py</code> <pre><code>def compute_heart_rate(\n    data: npt.NDArray, sample_rate: float = 1000, method: str = \"fft\", **kwargs: dict\n) -&gt; tuple[float, float]:\n    \"\"\"Compute heart rate in BPM from PPG signal.\n\n    Args:\n        data (array): PPG signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        method (str, optional): Method to compute heart rate. Defaults to 'fft'.\n        **kwargs (dict): Keyword arguments to pass to method.\n\n    Returns:\n        float: Heart rate in BPM.\n    \"\"\"\n    match method:\n        case \"fft\":\n            bpm, qos = compute_heart_rate_from_fft(data=data, sample_rate=sample_rate, **kwargs)\n        case \"peak\":\n            bpm, qos = compute_heart_rate_from_peaks(data=data, sample_rate=sample_rate, **kwargs)\n        case _:\n            raise NotImplementedError(f\"Heart rate computation method {method} not implemented.\")\n    # END MATCH\n    return bpm, qos\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.metrics.compute_heart_rate_from_fft","title":"<code>compute_heart_rate_from_fft(data, sample_rate=1000, lowcut=0.5, highcut=4.0)</code>","text":"<p>Compute heart rate from FFT of PPG signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>PPG signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Lowcut frequency in Hz. Defaults to 0.5 Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>4.0</code> )         \u2013          <p>Highcut frequency in Hz. Defaults to 4.0 Hz.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>         \u2013          <p>tuple[float, float]: Heart rate (BPM) and qos metric.</p> </li> </ul> Source code in <code>physiokit/ppg/metrics.py</code> <pre><code>def compute_heart_rate_from_fft(\n    data: npt.NDArray, sample_rate: float = 1000, lowcut: float = 0.5, highcut: float = 4.0\n) -&gt; tuple[float, float]:\n    \"\"\"Compute heart rate from FFT of PPG signal.\n\n    Args:\n        data (array): PPG signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        lowcut (float, optional): Lowcut frequency in Hz. Defaults to 0.5 Hz.\n        highcut (float, optional): Highcut frequency in Hz. Defaults to 4.0 Hz.\n\n    Returns:\n        tuple[float, float]: Heart rate (BPM) and qos metric.\n    \"\"\"\n    freqs, sp = compute_fft(data, sample_rate)\n    l_idx = np.where(freqs &gt;= lowcut)[0][0]\n    r_idx = np.where(freqs &gt;= highcut)[0][0]\n    freqs = freqs[l_idx:r_idx]\n    ps = 2 * np.abs(sp[l_idx:r_idx])\n    fft_pk_idx = np.argmax(ps)\n    bpm = 60 * freqs[fft_pk_idx]\n    qos = ps[fft_pk_idx] / np.sum(ps)\n    return bpm, qos\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.metrics.compute_heart_rate_from_peaks","title":"<code>compute_heart_rate_from_peaks(data, sample_rate=1000, min_rr=0.3, max_rr=2.0, min_delta=0.3)</code>","text":"<p>Compute heart rate from peaks of PPG signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>PPG signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>min_rr</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum RR interval in seconds. Defaults to 0.3 s.</p> </li> <li> <code>max_rr</code>             (<code>float</code>, default:                 <code>2.0</code> )         \u2013          <p>Maximum RR interval in seconds. Defaults to 2.0 s.</p> </li> <li> <code>min_delta</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum RR interval delta. Defaults to 0.3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>         \u2013          <p>tuple[float, float]: Heart rate (BPM) and qos metric.</p> </li> </ul> Source code in <code>physiokit/ppg/metrics.py</code> <pre><code>def compute_heart_rate_from_peaks(\n    data: npt.NDArray, sample_rate: float = 1000, min_rr: float = 0.3, max_rr: float = 2.0, min_delta: float = 0.3\n) -&gt; tuple[float, float]:\n    \"\"\"Compute heart rate from peaks of PPG signal.\n\n    Args:\n        data (array): PPG signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        min_rr (float, optional): Minimum RR interval in seconds. Defaults to 0.3 s.\n        max_rr (float, optional): Maximum RR interval in seconds. Defaults to 2.0 s.\n        min_delta (float, optional): Minimum RR interval delta. Defaults to 0.3.\n\n    Returns:\n        tuple[float, float]: Heart rate (BPM) and qos metric.\n    \"\"\"\n    peaks = find_peaks(data=data, sample_rate=sample_rate)\n    rri = compute_rr_intervals(peaks=peaks)\n    rmask = filter_rr_intervals(rr_ints=rri, sample_rate=sample_rate, min_rr=min_rr, max_rr=max_rr, min_delta=min_delta)\n    bpm = 60 / (np.nanmean(rri[rmask == 0]) / sample_rate)\n    qos = rmask[rmask == 0].size / rmask.size\n    return bpm, qos\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.metrics.compute_spo2_from_perfusion","title":"<code>compute_spo2_from_perfusion(dc1, ac1, dc2, ac2, coefs=(1, 0, 0))</code>","text":"<p>Compute SpO2 from ratio of perfusion indexes (AC/DC).</p> Device Coefficients <ul> <li>MAX30101: [1.5958422, -34.6596622, 112.6898759]</li> <li>MAX8614X: [-16.666666, 8.333333, 100]</li> </ul> <p>Parameters:</p> <ul> <li> <code>dc1</code>             (<code>float</code>)         \u2013          <p>DC component of 1st PPG signal (e.g RED).</p> </li> <li> <code>ac1</code>             (<code>float</code>)         \u2013          <p>AC component of 1st PPG signal (e.g RED).</p> </li> <li> <code>dc2</code>             (<code>float</code>)         \u2013          <p>DC component of 2nd PPG signal (e.g. IR).</p> </li> <li> <code>ac2</code>             (<code>float</code>)         \u2013          <p>AC component of 2nd PPG signal (e.g. IR).</p> </li> <li> <code>coefs</code>             (<code>tuple[float, float, float]</code>, default:                 <code>(1, 0, 0)</code> )         \u2013          <p>Calibration coefficients. Defaults to (1, 0, 0).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>SpO2 value clipped to [50, 100].</p> </li> </ul> Source code in <code>physiokit/ppg/metrics.py</code> <pre><code>def compute_spo2_from_perfusion(\n    dc1: float, ac1: float, dc2: float, ac2: float, coefs: tuple[float, float, float] = (1, 0, 0)\n) -&gt; float:\n    \"\"\"Compute SpO2 from ratio of perfusion indexes (AC/DC).\n\n    Device Coefficients:\n        * MAX30101: [1.5958422, -34.6596622, 112.6898759]\n        * MAX8614X: [-16.666666, 8.333333, 100]\n\n    Args:\n        dc1 (float): DC component of 1st PPG signal (e.g RED).\n        ac1 (float): AC component of 1st PPG signal (e.g RED).\n        dc2 (float): DC component of 2nd PPG signal (e.g. IR).\n        ac2 (float): AC component of 2nd PPG signal (e.g. IR).\n        coefs (tuple[float, float, float], optional): Calibration coefficients. Defaults to (1, 0, 0).\n\n    Returns:\n        float: SpO2 value clipped to [50, 100].\n    \"\"\"\n    r = (ac1 / dc1) / (ac2 / dc2)\n    spo2 = coefs[0] * r**2 + coefs[1] * r + coefs[2]\n    return max(min(spo2, 100), 50)\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.metrics.compute_spo2_in_frequency","title":"<code>compute_spo2_in_frequency(ppg1, ppg2, coefs=(1, 0, 0), sample_rate=1000, lowcut=0.5, highcut=4.0, order=3)</code>","text":"<p>Compute SpO2 from PPG signals in frequency domain.</p> <p>Parameters:</p> <ul> <li> <code>ppg1</code>             (<code>array</code>)         \u2013          <p>1st PPG signal (e.g RED).</p> </li> <li> <code>ppg2</code>             (<code>array</code>)         \u2013          <p>2nd PPG signal (e.g. IR).</p> </li> <li> <code>coefs</code>             (<code>tuple[float, float, float]</code>, default:                 <code>(1, 0, 0)</code> )         \u2013          <p>Calibration coefficients. Defaults to (1, 0, 0).</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Lowcut frequency in Hz. Defaults to 0.5 Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>4.0</code> )         \u2013          <p>Highcut frequency in Hz. Defaults to 4.0 Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>Order of filter. Defaults to 3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>SpO2 value</p> </li> </ul> Source code in <code>physiokit/ppg/metrics.py</code> <pre><code>def compute_spo2_in_frequency(\n    ppg1: npt.NDArray,\n    ppg2: npt.NDArray,\n    coefs: tuple[float, float, float] = (1, 0, 0),\n    sample_rate: float = 1000,\n    lowcut: float = 0.5,\n    highcut: float = 4.0,\n    order: int = 3,\n) -&gt; float:\n    \"\"\"Compute SpO2 from PPG signals in frequency domain.\n\n    Args:\n        ppg1 (array): 1st PPG signal (e.g RED).\n        ppg2 (array): 2nd PPG signal (e.g. IR).\n        coefs (tuple[float, float, float], optional): Calibration coefficients. Defaults to (1, 0, 0).\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        lowcut (float, optional): Lowcut frequency in Hz. Defaults to 0.5 Hz.\n        highcut (float, optional): Highcut frequency in Hz. Defaults to 4.0 Hz.\n        order (int, optional): Order of filter. Defaults to 3.\n\n    Returns:\n        float: SpO2 value\n    \"\"\"\n\n    # Compute DC\n    ppg1_dc = np.mean(ppg1)\n    ppg2_dc = np.mean(ppg2)\n\n    # Bandpass filter\n    ppg1_clean = filter_signal(\n        data=ppg1, lowcut=lowcut, highcut=highcut, sample_rate=sample_rate, order=order, forward_backward=True\n    )\n    ppg2_clean = filter_signal(\n        data=ppg2, lowcut=lowcut, highcut=highcut, sample_rate=sample_rate, order=order, forward_backward=True\n    )\n\n    # Compute AC via FFT\n    freqs, ppg1_fft = compute_fft(ppg1_clean, sample_rate=sample_rate)\n    freqs, ppg2_fft = compute_fft(ppg2_clean, sample_rate=sample_rate)\n\n    l_idx = np.where(freqs &gt;= lowcut)[0][0]\n    r_idx = np.where(freqs &gt;= highcut)[0][0]\n\n    freqs = freqs[l_idx:r_idx]\n    ppg1_ps = 2 * np.abs(ppg1_fft[l_idx:r_idx])\n    ppg2_ps = 2 * np.abs(ppg2_fft[l_idx:r_idx])\n\n    # Find peak\n    fft_pk_idx = np.argmax(ppg1_ps + ppg2_ps)\n\n    # Compute AC\n    ppg1_ac = ppg1_ps[fft_pk_idx]\n    ppg2_ac = ppg2_ps[fft_pk_idx]\n\n    spo2 = compute_spo2_from_perfusion(dc1=ppg1_dc, ac1=ppg1_ac, dc2=ppg2_dc, ac2=ppg2_ac, coefs=coefs)\n\n    return spo2\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.metrics.compute_spo2_in_time","title":"<code>compute_spo2_in_time(ppg1, ppg2, coefs=(1, 0, 0), sample_rate=1000, lowcut=0.5, highcut=4, order=3)</code>","text":"<p>Compute SpO2 from PPG signals in time domain.</p> <p>Parameters:</p> <ul> <li> <code>ppg1</code>             (<code>array</code>)         \u2013          <p>1st PPG signal (e.g RED).</p> </li> <li> <code>ppg2</code>             (<code>array</code>)         \u2013          <p>2nd PPG signal (e.g. IR).</p> </li> <li> <code>coefs</code>             (<code>tuple[float, float, float]</code>, default:                 <code>(1, 0, 0)</code> )         \u2013          <p>Calibration coefficients. Defaults to (1, 0, 0).</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Lowcut frequency in Hz. Defaults to 0.5 Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>4</code> )         \u2013          <p>Highcut frequency in Hz. Defaults to 4.0 Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>Order of filter. Defaults to 3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>float</code> )        \u2013          <p>SpO2 value</p> </li> </ul> Source code in <code>physiokit/ppg/metrics.py</code> <pre><code>def compute_spo2_in_time(\n    ppg1: npt.NDArray,\n    ppg2: npt.NDArray,\n    coefs: tuple[float, float, float] = (1, 0, 0),\n    sample_rate: float = 1000,\n    lowcut: float = 0.5,\n    highcut: float = 4,\n    order: int = 3,\n) -&gt; float:\n    \"\"\"Compute SpO2 from PPG signals in time domain.\n\n    Args:\n        ppg1 (array): 1st PPG signal (e.g RED).\n        ppg2 (array): 2nd PPG signal (e.g. IR).\n        coefs (tuple[float, float, float], optional): Calibration coefficients. Defaults to (1, 0, 0).\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        lowcut (float, optional): Lowcut frequency in Hz. Defaults to 0.5 Hz.\n        highcut (float, optional): Highcut frequency in Hz. Defaults to 4.0 Hz.\n        order (int, optional): Order of filter. Defaults to 3.\n\n    Returns:\n        float: SpO2 value\n    \"\"\"\n\n    # Compute DC\n    ppg1_dc = np.mean(ppg1)\n    ppg2_dc = np.mean(ppg2)\n\n    # Bandpass filter\n    ppg1_clean = filter_signal(\n        data=ppg1, lowcut=lowcut, highcut=highcut, sample_rate=sample_rate, order=order, forward_backward=True\n    )\n\n    ppg2_clean = filter_signal(\n        data=ppg2, lowcut=lowcut, highcut=highcut, sample_rate=sample_rate, order=order, forward_backward=True\n    )\n\n    # Compute AC via RMS\n    ppg1_ac = np.sqrt(np.mean(ppg1_clean**2))\n    ppg2_ac = np.sqrt(np.mean(ppg2_clean**2))\n\n    spo2 = compute_spo2_from_perfusion(dc1=ppg1_dc, ac1=ppg1_ac, dc2=ppg2_dc, ac2=ppg2_ac, coefs=coefs)\n    return spo2\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.metrics.derive_respiratory_rate","title":"<code>derive_respiratory_rate(ppg, peaks, troughs=None, rri=None, sample_rate=1000, method='rifv', lowcut=0.1, highcut=1.0, order=3, threshold=0.85, interpolate_method='linear')</code>","text":"<p>Derive respiratory rate from PPG signal using given method.</p> <p>Parameters:</p> <ul> <li> <code>ppg</code>             (<code>array</code>)         \u2013          <p>PPG signal.</p> </li> <li> <code>peaks</code>             (<code>array</code>)         \u2013          <p>Peaks of PPG signal.</p> </li> <li> <code>troughs</code>             (<code>array</code>, default:                 <code>None</code> )         \u2013          <p>Troughs of PPG signal. Defaults to None.</p> </li> <li> <code>rri</code>             (<code>array</code>, default:                 <code>None</code> )         \u2013          <p>Respiratory interval. Defaults to None.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'rifv'</code> )         \u2013          <p>Method to compute respiratory rate. Defaults to 'riav'.</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>Lowcut frequency in Hz. Defaults to 0.1 Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Highcut frequency in Hz. Defaults to 1.0 Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>Order of filter. Defaults to 3.</p> </li> <li> <code>threshold</code>             (<code>float</code>, default:                 <code>0.85</code> )         \u2013          <p>Threshold for peak detection. Defaults to 0.85.</p> </li> <li> <code>interpolate_method</code>             (<code>str</code>, default:                 <code>'linear'</code> )         \u2013          <p>Interpolation method. Defaults to 'linear'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>         \u2013          <p>tuple[float, float]: Respiratory rate (BPM) and qos metric.</p> </li> </ul> Source code in <code>physiokit/ppg/metrics.py</code> <pre><code>def derive_respiratory_rate(\n    ppg: npt.NDArray,\n    peaks: npt.NDArray,\n    troughs: npt.NDArray | None = None,\n    rri: npt.NDArray | None = None,\n    sample_rate: float = 1000,\n    method: Literal[\"riav\", \"riiv\", \"rifv\"] = \"rifv\",\n    lowcut: float = 0.1,\n    highcut: float = 1.0,\n    order: int = 3,\n    threshold: float | None = 0.85,\n    interpolate_method: str = \"linear\",\n) -&gt; tuple[float, float]:\n    \"\"\"Derive respiratory rate from PPG signal using given method.\n\n    Args:\n        ppg (array): PPG signal.\n        peaks (array): Peaks of PPG signal.\n        troughs (array, optional): Troughs of PPG signal. Defaults to None.\n        rri (array, optional): Respiratory interval. Defaults to None.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        method (str, optional): Method to compute respiratory rate. Defaults to 'riav'.\n        lowcut (float, optional): Lowcut frequency in Hz. Defaults to 0.1 Hz.\n        highcut (float, optional): Highcut frequency in Hz. Defaults to 1.0 Hz.\n        order (int, optional): Order of filter. Defaults to 3.\n        threshold (float, optional): Threshold for peak detection. Defaults to 0.85.\n        interpolate_method (str, optional): Interpolation method. Defaults to 'linear'.\n\n    Returns:\n        tuple[float, float]: Respiratory rate (BPM) and qos metric.\n    \"\"\"\n    if peaks.size &lt; 4:\n        raise ValueError(\"At least 4 peaks are required to compute respiratory rate\")\n\n    ts = np.arange(peaks[0], peaks[-1], 1)\n    match method:\n        case \"riav\":\n            rsp = ppg[peaks] - ppg[troughs]\n        case \"riiv\":\n            rsp = ppg[peaks]\n        case \"rifv\":\n            rsp = rri\n        case _:\n            raise ValueError(f\"Method {method} not implemented\")\n    rsp = scipy.interpolate.interp1d(peaks, rsp, kind=interpolate_method, fill_value=\"extrapolate\")(ts)\n    rsp = filter_signal(rsp, lowcut=lowcut, highcut=highcut, sample_rate=sample_rate, order=order)\n\n    freqs, rsp_sp = compute_fft(rsp, sample_rate=sample_rate)\n    l_idx = np.where(freqs &gt;= lowcut)[0][0]\n    r_idx = np.where(freqs &gt;= highcut)[0][0]\n    rsp_ps = 2 * np.abs(rsp_sp)\n    freqs = freqs[l_idx:r_idx]\n    rsp_ps = rsp_ps[l_idx:r_idx]\n\n    fft_pk_idx = np.argmax(rsp_ps)\n    if threshold is not None:\n        fft_pk_indices = np.where(rsp_ps &gt; threshold * rsp_ps[fft_pk_idx])[0]\n    else:\n        fft_pk_indices = [fft_pk_idx]\n\n    rsp_bpm_weights = rsp_ps[fft_pk_indices]\n    tgt_pwr = np.sum(rsp_bpm_weights)\n    qos = tgt_pwr / np.sum(rsp_ps)\n    rsp_bpm = 60 * np.sum(rsp_bpm_weights * freqs[fft_pk_indices]) / tgt_pwr\n    return rsp_bpm, qos\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.peaks","title":"<code>physiokit.ppg.peaks</code>","text":""},{"location":"api/ppg/#physiokit.ppg.peaks.compute_rr_intervals","title":"<code>compute_rr_intervals(peaks)</code>","text":"<p>Compute RR intervals from R peaks.</p> <p>Parameters:</p> <ul> <li> <code>peaks</code>             (<code>array</code>)         \u2013          <p>R peaks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: RR intervals.</p> </li> </ul> Source code in <code>physiokit/ppg/peaks.py</code> <pre><code>def compute_rr_intervals(\n    peaks: npt.NDArray,\n) -&gt; npt.NDArray:\n    \"\"\"Compute RR intervals from R peaks.\n\n    Args:\n        peaks (array): R peaks.\n\n    Returns:\n        npt.NDArray: RR intervals.\n    \"\"\"\n\n    rr_ints = np.diff(peaks)\n    if rr_ints.size == 0:\n        return rr_ints\n    rr_ints = np.hstack((rr_ints[0], rr_ints))\n    return rr_ints\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.peaks.filter_peaks","title":"<code>filter_peaks(peaks, sample_rate=1000, min_rr=0.3, max_rr=2.0, min_delta=0.3)</code>","text":"<p>Filter out peaks with RR intervals outside of normal range.</p> <p>Parameters:</p> <ul> <li> <code>peaks</code>             (<code>array</code>)         \u2013          <p>Systolic peaks.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>min_rr</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum RR interval in seconds. Defaults to 0.3 s.</p> </li> <li> <code>max_rr</code>             (<code>float</code>, default:                 <code>2.0</code> )         \u2013          <p>Maximum RR interval in seconds. Defaults to 2.0 s.</p> </li> <li> <code>min_delta</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum RR interval delta. Defaults to 0.3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Filtered peaks.</p> </li> </ul> Source code in <code>physiokit/ppg/peaks.py</code> <pre><code>def filter_peaks(\n    peaks: npt.NDArray,\n    sample_rate: float = 1000,\n    min_rr: float = 0.3,\n    max_rr: float = 2.0,\n    min_delta: float | None = 0.3,\n) -&gt; npt.NDArray:\n    \"\"\"Filter out peaks with RR intervals outside of normal range.\n\n    Args:\n        peaks (array): Systolic peaks.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        min_rr (float, optional): Minimum RR interval in seconds. Defaults to 0.3 s.\n        max_rr (float, optional): Maximum RR interval in seconds. Defaults to 2.0 s.\n        min_delta (float, optional): Minimum RR interval delta. Defaults to 0.3.\n\n    Returns:\n        npt.NDArray: Filtered peaks.\n    \"\"\"\n    if peaks.size &lt;= 1:\n        return peaks\n    # Capture RR intervals\n    rr_ints = np.diff(peaks)\n    rr_ints = np.hstack((rr_ints[0], rr_ints))\n\n    # Filter out peaks with RR intervals outside of normal range\n    rr_mask = np.where((rr_ints &lt; min_rr * sample_rate) | (rr_ints &gt; max_rr * sample_rate), 1, 0)\n\n    # Filter out peaks that deviate more than delta\n    if min_delta is not None:\n        rr_mask = quotient_filter_mask(rr_ints, mask=rr_mask, lowcut=1 - min_delta, highcut=1 + min_delta)\n    filt_peaks = peaks[np.where(rr_mask == 0)[0]]\n    return filt_peaks\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.peaks.filter_rr_intervals","title":"<code>filter_rr_intervals(rr_ints, sample_rate=1000, min_rr=0.3, max_rr=2.0, min_delta=0.3)</code>","text":"<p>Filter out peaks with RR intervals outside of normal range.</p> <p>Parameters:</p> <ul> <li> <code>rr_ints</code>             (<code>array</code>)         \u2013          <p>RR intervals.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>min_rr</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum RR interval in seconds. Defaults to 0.3 s.</p> </li> <li> <code>max_rr</code>             (<code>float</code>, default:                 <code>2.0</code> )         \u2013          <p>Maximum RR interval in seconds. Defaults to 2.0 s.</p> </li> <li> <code>min_delta</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Minimum RR interval delta. Defaults to 0.3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Filtered RR intervals.</p> </li> </ul> Source code in <code>physiokit/ppg/peaks.py</code> <pre><code>def filter_rr_intervals(\n    rr_ints: npt.NDArray, sample_rate: float = 1000, min_rr: float = 0.3, max_rr: float = 2.0, min_delta: float = 0.3\n) -&gt; npt.NDArray:\n    \"\"\"Filter out peaks with RR intervals outside of normal range.\n\n    Args:\n        rr_ints (array): RR intervals.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        min_rr (float, optional): Minimum RR interval in seconds. Defaults to 0.3 s.\n        max_rr (float, optional): Maximum RR interval in seconds. Defaults to 2.0 s.\n        min_delta (float, optional): Minimum RR interval delta. Defaults to 0.3.\n\n    Returns:\n        npt.NDArray: Filtered RR intervals.\n    \"\"\"\n    if rr_ints.size == 0:\n        return np.array([])\n\n    # Filter out peaks with RR intervals outside of normal range\n    rr_mask = np.where((rr_ints &lt; min_rr * sample_rate) | (rr_ints &gt; max_rr * sample_rate), 1, 0)\n\n    # Filter out peaks that deviate more than delta\n    rr_mask = quotient_filter_mask(rr_ints, mask=rr_mask, lowcut=1 - min_delta, highcut=1 + min_delta)\n\n    return rr_mask\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.peaks.find_peaks","title":"<code>find_peaks(data, sample_rate=1000, peak_window=0.111, beat_window=0.667, beat_offset=0.02, peak_delay=0.3)</code>","text":"<p>Find systolic peaks in PPG signal.</p> <p>Implementation based on Elgendi M, Norton I, Brearley M, Abbott D, Schuurmans D (2013) Systolic Peak Detection in Acceleration Photoplethysmograms Measured from Emergency Responders in Tropical Conditions. PLoS ONE 8(10): e76585. doi:10.1371/journal.pone.0076585. Assumes input data is bandpass filtered with a lowcut of .5 Hz and a highcut of 8 Hz.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>PPG signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>peak_window</code>             (<code>float</code>, default:                 <code>0.111</code> )         \u2013          <p>Peak window in seconds. Defaults to 0.111 s.</p> </li> <li> <code>beat_window</code>             (<code>float</code>, default:                 <code>0.667</code> )         \u2013          <p>Beat window in seconds. Defaults to 0.667 s.</p> </li> <li> <code>beat_offset</code>             (<code>float</code>, default:                 <code>0.02</code> )         \u2013          <p>Beat offset in seconds. Defaults to 0.02 s.</p> </li> <li> <code>peak_delay</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Peak delay in seconds. Defaults to 0.3 s.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Peak locations.</p> </li> </ul> Source code in <code>physiokit/ppg/peaks.py</code> <pre><code>def find_peaks(\n    data: npt.NDArray,\n    sample_rate: float = 1000,\n    peak_window: float = 0.111,\n    beat_window: float = 0.667,\n    beat_offset: float = 0.02,\n    peak_delay: float = 0.3,\n) -&gt; npt.NDArray:\n    \"\"\"Find systolic peaks in PPG signal.\n\n    Implementation based on Elgendi M, Norton I, Brearley M, Abbott D, Schuurmans D (2013) Systolic Peak Detection in\n    Acceleration Photoplethysmograms Measured from Emergency Responders in Tropical Conditions. PLoS ONE 8(10): e76585.\n    doi:10.1371/journal.pone.0076585.\n    Assumes input data is bandpass filtered with a lowcut of .5 Hz and a highcut of 8 Hz.\n\n    Args:\n        data (array): PPG signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        peak_window (float, optional): Peak window in seconds. Defaults to 0.111 s.\n        beat_window (float, optional): Beat window in seconds. Defaults to 0.667 s.\n        beat_offset (float, optional): Beat offset in seconds. Defaults to 0.02 s.\n        peak_delay (float, optional): Peak delay in seconds. Defaults to 0.3 s.\n\n    Returns:\n        npt.NDArray: Peak locations.\n    \"\"\"\n\n    # Clip negative values and square the signal\n    sqrd = np.where(data &gt; 0, data**2, 0)\n\n    # Apply 1st moving average filter\n    ma_peak_kernel = int(np.rint(peak_window * sample_rate))\n    ma_peak = spn.uniform_filter1d(sqrd, ma_peak_kernel, mode=\"nearest\")\n\n    # Apply 2nd moving average filter\n    ma_beat_kernel = int(np.rint(beat_window * sample_rate))\n    ma_beat = spn.uniform_filter1d(sqrd, ma_beat_kernel, mode=\"nearest\")\n\n    # Thresholds\n    min_height = ma_beat + beat_offset * np.mean(sqrd)\n    min_width = int(np.rint(peak_window * sample_rate))\n    min_delay = int(np.rint(peak_delay * sample_rate))\n\n    # Identify wave boundaries\n    waves = ma_peak &gt; min_height\n    beg_waves = np.where(np.logical_and(np.logical_not(waves[0:-1]), waves[1:]))[0]\n    end_waves = np.where(np.logical_and(waves[0:-1], np.logical_not(waves[1:])))[0]\n    end_waves = end_waves[end_waves &gt; beg_waves[0]]\n\n    # Identify systolic peaks\n    peaks = []\n    for i in range(min(beg_waves.size, end_waves.size)):\n        beg, end = beg_waves[i], end_waves[i]\n        peak = beg + np.argmax(data[beg:end])\n        peak_width = end - beg\n        peak_delay = peak - peaks[-1] if peaks else min_delay\n\n        # Enforce minimum length and delay between peaks\n        if (peak_width &lt; min_width) or (peak_delay &lt; min_delay):\n            continue\n        peaks.append(peak)\n    # END FOR\n\n    return np.array(peaks, dtype=int)\n</code></pre>"},{"location":"api/ppg/#physiokit.ppg.synthesize","title":"<code>physiokit.ppg.synthesize</code>","text":""},{"location":"api/ppg/#physiokit.ppg.synthesize.synthesize","title":"<code>synthesize(signal_length=10000, sample_rate=1000, heart_rate=60, frequency_modulation=0.3, ibi_randomness=0.1)</code>","text":"<p>Generate synthetic PPG signal. Utilize pk.signal.noise methods to make more realistic.</p> <p>Parameters:</p> <ul> <li> <code>signal_length</code>             (<code>int</code>, default:                 <code>10000</code> )         \u2013          <p>Length of signal in samples. Defaults to 10000.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sample rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>heart_rate</code>             (<code>float</code>, default:                 <code>60</code> )         \u2013          <p>Heart rate in BPM. Defaults to 60 BPM.</p> </li> <li> <code>frequency_modulation</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Frequency modulation strength [0,1]. Defaults to 0.3.</p> </li> <li> <code>ibi_randomness</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>IBI randomness in range [0,1]. Defaults to 0.1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[NDArray, NDArray, NDArray]</code>         \u2013          <p>npt.NDArray: Synthetic PPG, segmentation mask, fiducial mask</p> </li> </ul> Source code in <code>physiokit/ppg/synthesize.py</code> <pre><code>def synthesize(\n    signal_length: int = 10000,\n    sample_rate: float = 1000,\n    heart_rate: float = 60,\n    frequency_modulation: float = 0.3,\n    ibi_randomness: float = 0.1,\n) -&gt; tuple[npt.NDArray, npt.NDArray, npt.NDArray]:\n    \"\"\"Generate synthetic PPG signal. Utilize pk.signal.noise methods to make more realistic.\n\n    Args:\n        signal_length (int, optional): Length of signal in samples. Defaults to 10000.\n        sample_rate (float, optional): Sample rate in Hz. Defaults to 1000 Hz.\n        heart_rate (float, optional): Heart rate in BPM. Defaults to 60 BPM.\n        frequency_modulation (float, optional): Frequency modulation strength [0,1]. Defaults to 0.3.\n        ibi_randomness (float, optional): IBI randomness in range [0,1]. Defaults to 0.1.\n\n    Returns:\n        npt.NDArray: Synthetic PPG, segmentation mask, fiducial mask\n    \"\"\"\n    duration = signal_length / sample_rate\n    period = 60 / heart_rate  # in seconds\n    n_period = int(np.rint(duration / period) + 1)\n    periods = np.ones(n_period) * period\n\n    # Mark onset of each wave in seconds\n    x_onset = np.cumsum(periods)\n    x_onset -= x_onset[0]  # make sure seconds start at zero\n\n    # Add respiratory sinus arrythmia (RSA)\n    periods, x_onset = _frequency_modulation(\n        periods,\n        x_onset,\n        modulation_frequency=0.05,\n        modulation_strength=frequency_modulation,\n    )\n\n    # Modulate onset of each wave randomly ~[0, ibi_randomness]\n    x_onset = _random_x_offset(x_onset, ibi_randomness)\n    y_onset = np.random.normal(0, 0.1, n_period)\n\n    # Create systolic peaks within the waves in seconds\n    x_sys = x_onset + np.random.normal(0.175, 0.01, n_period) * periods\n    y_sys = y_onset + np.random.normal(1.5, 0.15, n_period)\n\n    # Create dicrotic notches within the waves in seconds\n    x_notch = x_onset + np.random.normal(0.4, 0.001, n_period) * periods\n    y_notch = y_sys * np.random.normal(0.49, 0.01, n_period)\n\n    # Create diastolic peaks within the waves in seconds\n    x_dia = x_onset + np.random.normal(0.45, 0.001, n_period) * periods\n    y_dia = y_sys * np.random.normal(0.51, 0.01, n_period)\n\n    # Convert seconds to sample\n    x_onset_n = np.ceil(x_onset * sample_rate).astype(int)\n    x_sys_n = np.ceil(x_sys * sample_rate).astype(int)\n    x_notch_n = np.ceil(x_notch * sample_rate).astype(int)\n    x_dia_n = np.ceil(x_dia * sample_rate).astype(int)\n\n    # Concatenate all landmarks and sort them\n    x_all = np.concatenate((x_onset_n, x_sys_n, x_notch_n, x_dia_n))\n    x_all.sort(kind=\"mergesort\")\n\n    y_all = np.zeros(n_period * 4)\n    y_all[0::4] = y_onset\n    y_all[1::4] = y_sys\n    y_all[2::4] = y_notch\n    y_all[3::4] = y_dia\n\n    # Interpolate a continuous signal between the landmarks (i.e., Cartesian coordinates).\n    samples = np.arange(int(np.ceil(duration * sample_rate)))\n\n    # Create fiducial mask\n    fids = np.zeros(len(samples), dtype=np.int32)\n    fids[x_sys_n[x_sys_n &lt; fids.size]] = PpgFiducial.systolic_peak\n    fids[x_notch_n[x_notch_n &lt; fids.size]] = PpgFiducial.dicrotic_notch\n    fids[x_dia_n[x_dia_n &lt; fids.size]] = PpgFiducial.diastolic_peak\n\n    # Create segmentation mask\n    x_sys_seg = np.concatenate((x_onset_n, x_dia_n - 1))\n    x_sys_seg.sort(kind=\"mergesort\")\n    segs = np.full(len(samples), fill_value=PpgSegment.diastolic, dtype=np.int32)\n    for i in range(len(x_sys_seg) // 2):\n        segs[x_sys_seg[2 * i] : x_sys_seg[2 * i + 1]] = PpgSegment.systolic\n\n    # Interpolate\n    interp_function = scipy.interpolate.Akima1DInterpolator(x_all, y_all)\n    ppg = interp_function(samples)\n\n    ppg = ppg[:signal_length]\n    segs = segs[:signal_length]\n    fids = fids[:signal_length]\n\n    return ppg, segs, fids\n</code></pre>"},{"location":"api/rsp/","title":"Respiratory (RSP)","text":"<p>Respiratory rate is often measured on the chest using a respiration belt or a respiratory inductance plethysmography (RIP) sensor. PhysioKit provides a set of functions to process RSP signals. The functions can be used to generate synthetic RSP signals, clean noisy RSP signals, extract respiratory peaks, compute respiratory rate, and compute dual band metrics.</p>"},{"location":"api/rsp/#physiokit.rsp.defines","title":"<code>physiokit.rsp.defines</code>","text":""},{"location":"api/rsp/#physiokit.rsp.defines.RspDualMetrics","title":"<code>RspDualMetrics</code>  <code>dataclass</code>","text":"<p>Respiratory dual band metrics.</p> Source code in <code>physiokit/rsp/defines.py</code> <pre><code>@dataclass\nclass RspDualMetrics:\n    \"\"\"Respiratory dual band metrics.\"\"\"\n\n    rc_rr: float = 0  # RC respiratory rate (BPM)\n    ab_rr: float = 0  # AB respiratory rate (BPM)\n    vt_rr: float = 0  # VT respiratory rate (BPM)\n    phase: float = 0  # Phase angle (degrees)\n    lbi: float = 0  # Labored breathing index\n    rc_lead: bool = False  # RC leads AB\n    rc_percent: float = 0  # Percent RC contribution\n    qos: float = 0  # Quality of signal (0-1)\n\n    rc_pk_freq: float = 0  # RC peak frequency (Hz)\n    rc_pk_pwr: float = 0  # RC peak power\n    ab_pk_freq: float = 0  # AB peak frequency (Hz)\n    ab_pk_pwr: float = 0  # AB peak power\n    vt_pk_freq: float = 0  # VT peak frequency (Hz)\n    vt_pk_pwr: float = 0  # VT peak power\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.defines.RspFiducial","title":"<code>RspFiducial</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>RSP fiducials labels</p> Source code in <code>physiokit/rsp/defines.py</code> <pre><code>class RspFiducial(IntEnum):\n    \"\"\"RSP fiducials labels\"\"\"\n\n    inhale_peak = 1\n    exhale_trough = 2\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.defines.RspSegment","title":"<code>RspSegment</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>RSP Segment labels</p> Source code in <code>physiokit/rsp/defines.py</code> <pre><code>class RspSegment(IntEnum):\n    \"\"\"RSP Segment labels\"\"\"\n\n    background = 0\n    inhale = 1\n    exhale = 2\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.clean","title":"<code>physiokit.rsp.clean</code>","text":""},{"location":"api/rsp/#physiokit.rsp.clean.clean","title":"<code>clean(data, lowcut=0.05, highcut=3, sample_rate=1000, order=3, axis=-1, forward_backward=True)</code>","text":"<p>Clean respiratory signal using biquad filter.</p> <p>By default, applies a 3rd order Butterworth filter between 0.05 and 3 Hz.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.05</code> )         \u2013          <p>Lower cutoff in Hz. Defaults to 0.05 Hz (3 bpm).</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>3</code> )         \u2013          <p>Upper cutoff in Hz. Defaults to 3 Hz (180 bpm).</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sample rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>Filter order. Defaults to 3 (3rd order Butterworth filter).</p> </li> <li> <code>axis</code>             (<code>int</code>, default:                 <code>-1</code> )         \u2013          <p>Axis to apply against. Defaults to -1.</p> </li> <li> <code>forward_backward</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Apply filter forward and backward. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Cleaned signal</p> </li> </ul> Source code in <code>physiokit/rsp/clean.py</code> <pre><code>def clean(\n    data: npt.NDArray,\n    lowcut: float = 0.05,\n    highcut: float = 3,\n    sample_rate: float = 1000,\n    order: int = 3,\n    axis: int = -1,\n    forward_backward: bool = True,\n) -&gt; npt.NDArray:\n    \"\"\"Clean respiratory signal using biquad filter.\n\n    By default, applies a 3rd order Butterworth filter between 0.05 and 3 Hz.\n\n    Args:\n        data (npt.NDArray): Signal\n        lowcut (float, optional): Lower cutoff in Hz. Defaults to 0.05 Hz (3 bpm).\n        highcut (float, optional): Upper cutoff in Hz. Defaults to 3 Hz (180 bpm).\n        sample_rate (float, optional): Sample rate in Hz. Defaults to 1000 Hz.\n        order (int, optional): Filter order. Defaults to 3 (3rd order Butterworth filter).\n        axis (int, optional): Axis to apply against. Defaults to -1.\n        forward_backward (bool, optional): Apply filter forward and backward. Defaults to True.\n\n    Returns:\n        npt.NDArray: Cleaned signal\n    \"\"\"\n\n    # Bandpass filter\n    return filter_signal(\n        data=data,\n        lowcut=lowcut,\n        highcut=highcut,\n        sample_rate=sample_rate,\n        order=order,\n        axis=axis,\n        forward_backward=forward_backward,\n    )\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.metrics","title":"<code>physiokit.rsp.metrics</code>","text":""},{"location":"api/rsp/#physiokit.rsp.metrics.compute_dual_band_metrics","title":"<code>compute_dual_band_metrics(rc, ab, sample_rate=1000, lowcut=0.05, highcut=3.0, fft_len=None, pwr_threshold=0.8)</code>","text":"<p>Compute respiratory dual band metrics.</p> <p>Parameters:</p> <ul> <li> <code>rc</code>             (<code>array</code>)         \u2013          <p>Ribcage band.</p> </li> <li> <code>ab</code>             (<code>array</code>)         \u2013          <p>Abdominal band.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.05</code> )         \u2013          <p>Lowcut frequency in Hz. Defaults to 0.05 Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>3.0</code> )         \u2013          <p>Highcut frequency in Hz. Defaults to 3.0 Hz.</p> </li> <li> <code>fft_len</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>FFT length. Defaults to None.</p> </li> <li> <code>pwr_threshold</code>             (<code>float</code>, default:                 <code>0.8</code> )         \u2013          <p>Power threshold. Defaults to 0.80.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RspDualMetrics</code> (            <code>RspDualMetrics</code> )        \u2013          <p>Respiratory dual band metrics.</p> </li> </ul> Source code in <code>physiokit/rsp/metrics.py</code> <pre><code>def compute_dual_band_metrics(\n    rc: npt.NDArray,\n    ab: npt.NDArray,\n    sample_rate: float = 1000,\n    lowcut: float = 0.05,\n    highcut: float = 3.0,\n    fft_len: int | None = None,\n    pwr_threshold: float = 0.80,\n) -&gt; RspDualMetrics:\n    \"\"\"Compute respiratory dual band metrics.\n\n    Args:\n        rc (array): Ribcage band.\n        ab (array): Abdominal band.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        lowcut (float, optional): Lowcut frequency in Hz. Defaults to 0.05 Hz.\n        highcut (float, optional): Highcut frequency in Hz. Defaults to 3.0 Hz.\n        fft_len (int, optional): FFT length. Defaults to None.\n        pwr_threshold (float, optional): Power threshold. Defaults to 0.80.\n\n    Returns:\n        RspDualMetrics: Respiratory dual band metrics.\n    \"\"\"\n\n    # Remove DC\n    rc = rc - rc.mean()\n    ab = ab - ab.mean()\n\n    # Compute Vt\n    vt = rc + ab\n\n    # Compute FFT\n    freqs, rc_sp = compute_fft(rc, sample_rate=sample_rate, fft_len=fft_len, window=\"blackman\")\n    freqs, ab_sp = compute_fft(ab, sample_rate=sample_rate, fft_len=fft_len, window=\"blackman\")\n    freqs, vt_sp = compute_fft(vt, sample_rate=sample_rate, fft_len=fft_len, window=\"blackman\")\n\n    # Clip to frequency band of interest\n    l_idx = np.where(freqs &gt;= lowcut)[0][0]\n    r_idx = np.where(freqs &gt;= highcut)[0][0]\n    freqs = freqs[l_idx:r_idx]\n    rc_sp = rc_sp[l_idx:r_idx]\n    ab_sp = ab_sp[l_idx:r_idx]\n    vt_sp = vt_sp[l_idx:r_idx]\n\n    # Compute power spectrum\n    rc_ps = 2 * np.abs(rc_sp)\n    ab_ps = 2 * np.abs(ab_sp)\n    vt_ps = 2 * np.abs(vt_sp)\n\n    # Compute Vtc (corrected Vt)\n    vtc_ps = rc_ps + ab_ps\n\n    # Find dominant frequency\n    rc_pk_idx = np.argmax(rc_ps)\n    ab_pk_idx = np.argmax(ab_ps)\n    # vt_pk_idx = np.argmax(vt_ps)\n    vtc_pk_idx = np.argmax(vtc_ps)\n\n    # Find all peaks above threshold\n    rc_pk_idxs = np.where(rc_ps &gt;= pwr_threshold * rc_ps[rc_pk_idx])[0]\n    rc_pk_vals = rc_ps[rc_pk_idxs]\n    ab_pk_idxs = np.where(ab_ps &gt;= pwr_threshold * ab_ps[ab_pk_idx])[0]\n    ab_pk_vals = ab_ps[ab_pk_idxs]\n\n    vtc_pk_idxs = np.where(vtc_ps &gt;= pwr_threshold * vtc_ps[vtc_pk_idx])[0]\n    vtc_pk_vals = vtc_ps[vtc_pk_idxs]\n\n    # Compute respiratory rates\n    rc_rr = 60 * np.sum(freqs[rc_pk_idxs] * rc_pk_vals) / np.sum(rc_pk_vals)\n    ab_rr = 60 * np.sum(freqs[ab_pk_idxs] * ab_pk_vals) / np.sum(ab_pk_vals)\n    vtc_rr = 60 * np.sum(freqs[vtc_pk_idxs] * vtc_pk_vals) / np.sum(vtc_pk_vals)\n\n    # Compute phase angle\n    vtc_dom_div = rc_sp[vtc_pk_idxs] / ab_sp[vtc_pk_idxs]\n    vtc_dom_angle = np.arctan2(np.imag(vtc_dom_div), np.real(vtc_dom_div))\n    angles = (180 / np.pi) * np.sum(vtc_dom_angle * vtc_pk_vals) / np.sum(vtc_pk_vals)\n    phase = np.abs(angles)\n    rc_lead = angles &gt; 0\n\n    # Compute LBI: \ud835\udeab Vtc / \ud835\udeab Vt\n    lbi = np.clip(np.sum(vtc_ps[vtc_pk_idxs]) / np.sum(vt_ps[vtc_pk_idxs]), 1, 10)\n\n    # Compute %RC\n    rc_percent = 100 * np.mean(rc_ps[vtc_pk_idxs] / (rc_ps[vtc_pk_idxs] + ab_ps[vtc_pk_idxs]))\n\n    # Compute QoS\n    qos = np.sum(rc_ps * ab_ps) / (np.sum(rc_ps) + np.sum(ab_ps))\n\n    return RspDualMetrics(\n        rc_rr=rc_rr,\n        ab_rr=ab_rr,\n        vt_rr=vtc_rr,\n        phase=phase,\n        lbi=lbi,\n        rc_lead=rc_lead,\n        rc_percent=rc_percent,\n        qos=qos,\n        rc_pk_freq=freqs[rc_pk_idx],\n        rc_pk_pwr=rc_ps[rc_pk_idx],\n        ab_pk_freq=freqs[ab_pk_idx],\n        ab_pk_pwr=ab_ps[ab_pk_idx],\n        vt_pk_freq=freqs[vtc_pk_idx],\n        vt_pk_pwr=vtc_ps[vtc_pk_idx],\n    )\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.metrics.compute_respiratory_rate","title":"<code>compute_respiratory_rate(data, sample_rate=1000, method='fft', **kwargs)</code>","text":"<p>Compute respiratory rate in BPM from signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>RSP signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>method</code>             (<code>str</code>, default:                 <code>'fft'</code> )         \u2013          <p>Method to compute respiratory rate. Defaults to 'fft'.</p> </li> <li> <code>**kwargs</code>             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>Keyword arguments to pass to method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>         \u2013          <p>tuple[float, float]: Respiratory rate (BPM) and qos metric.</p> </li> </ul> Source code in <code>physiokit/rsp/metrics.py</code> <pre><code>def compute_respiratory_rate(\n    data: npt.NDArray, sample_rate: float = 1000, method: str = \"fft\", **kwargs: dict\n) -&gt; tuple[float, float]:\n    \"\"\"Compute respiratory rate in BPM from signal.\n\n    Args:\n        data (array): RSP signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        method (str, optional): Method to compute respiratory rate. Defaults to 'fft'.\n        **kwargs (dict): Keyword arguments to pass to method.\n\n    Returns:\n        tuple[float, float]: Respiratory rate (BPM) and qos metric.\n    \"\"\"\n    match method:\n        case \"fft\":\n            bpm, qos = compute_respiratory_rate_from_fft(data=data, sample_rate=sample_rate, **kwargs)\n        case \"peak\":\n            bpm, qos = compute_respiratory_rate_from_peaks(data=data, sample_rate=sample_rate, **kwargs)\n        case _:\n            raise NotImplementedError(f\"Respiratory rate computation method {method} not implemented.\")\n    # END MATCH\n    return bpm, qos\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.metrics.compute_respiratory_rate_from_fft","title":"<code>compute_respiratory_rate_from_fft(data, sample_rate=1000, lowcut=0.05, highcut=3.0)</code>","text":"<p>Compute respiratory rate in BPM from FFT of respiratory signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>RSP signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.05</code> )         \u2013          <p>Lowcut frequency in Hz. Defaults to 0.05 Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>3.0</code> )         \u2013          <p>Highcut frequency in Hz. Defaults to 3.0 Hz.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>tuple[float, float]</code> )        \u2013          <p>Respiratory rate (BPM).</p> </li> </ul> Source code in <code>physiokit/rsp/metrics.py</code> <pre><code>def compute_respiratory_rate_from_fft(\n    data: npt.NDArray,\n    sample_rate: float = 1000,\n    lowcut: float = 0.05,\n    highcut: float = 3.0,\n) -&gt; tuple[float, float]:\n    \"\"\"Compute respiratory rate in BPM from FFT of respiratory signal.\n\n    Args:\n        data (array): RSP signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        lowcut (float, optional): Lowcut frequency in Hz. Defaults to 0.05 Hz.\n        highcut (float, optional): Highcut frequency in Hz. Defaults to 3.0 Hz.\n\n    Returns:\n        float: Respiratory rate (BPM).\n    \"\"\"\n    freqs, sp = compute_fft(data, sample_rate=sample_rate, window=\"blackman\")\n    l_idx = np.where(freqs &gt;= lowcut)[0][0]\n    r_idx = np.where(freqs &gt;= highcut)[0][0]\n    freqs = freqs[l_idx:r_idx]\n    ps = 2 * np.abs(sp[l_idx:r_idx])\n    fft_pk_idx = np.argmax(ps)\n    bpm = freqs[fft_pk_idx] * 60\n    qos = ps[fft_pk_idx] / np.sum(ps)\n    return bpm, qos\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.metrics.compute_respiratory_rate_from_peaks","title":"<code>compute_respiratory_rate_from_peaks(data, sample_rate=1000, min_rr=0.5, max_rr=20, min_delta=0.5)</code>","text":"<p>Compute respiratory rate in BPM from peaks of PPG signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>RSP signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>min_rr</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Minimum RR interval in seconds. Defaults to 0.5 s.</p> </li> <li> <code>max_rr</code>             (<code>float</code>, default:                 <code>20</code> )         \u2013          <p>Maximum RR interval in seconds. Defaults to 20 s.</p> </li> <li> <code>min_delta</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Minimum delta between RR intervals in seconds. Defaults to 0.5 s.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (            <code>tuple[float, float]</code> )        \u2013          <p>Respiratory rate (BPM).</p> </li> </ul> Source code in <code>physiokit/rsp/metrics.py</code> <pre><code>def compute_respiratory_rate_from_peaks(\n    data: npt.NDArray, sample_rate: float = 1000, min_rr: float = 0.5, max_rr: float = 20, min_delta: float = 0.5\n) -&gt; tuple[float, float]:\n    \"\"\"Compute respiratory rate in BPM from peaks of PPG signal.\n\n    Args:\n        data (array): RSP signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        min_rr (float, optional): Minimum RR interval in seconds. Defaults to 0.5 s.\n        max_rr (float, optional): Maximum RR interval in seconds. Defaults to 20 s.\n        min_delta (float, optional): Minimum delta between RR intervals in seconds. Defaults to 0.5 s.\n\n    Returns:\n        float: Respiratory rate (BPM).\n    \"\"\"\n    peaks = find_peaks(data=data, sample_rate=sample_rate)\n    rri = compute_rr_intervals(peaks=peaks)\n    rmask = filter_rr_intervals(rr_ints=rri, sample_rate=sample_rate, min_rr=min_rr, max_rr=max_rr, min_delta=min_delta)\n\n    bpm = 60 / (np.nanmean(rri[rmask == 0]) / sample_rate)\n    qos = rmask[rmask == 0].size / rmask.size\n    return bpm, qos\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.peaks","title":"<code>physiokit.rsp.peaks</code>","text":""},{"location":"api/rsp/#physiokit.rsp.peaks.compute_rr_intervals","title":"<code>compute_rr_intervals(peaks)</code>","text":"<p>Compute RR intervals from resp peaks.</p> <p>Parameters:</p> <ul> <li> <code>peaks</code>             (<code>array</code>)         \u2013          <p>R peaks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: RR intervals.</p> </li> </ul> Source code in <code>physiokit/rsp/peaks.py</code> <pre><code>def compute_rr_intervals(\n    peaks: npt.NDArray,\n) -&gt; npt.NDArray:\n    \"\"\"Compute RR intervals from resp peaks.\n\n    Args:\n        peaks (array): R peaks.\n\n    Returns:\n        npt.NDArray: RR intervals.\n    \"\"\"\n\n    rr_ints = np.diff(peaks)\n    if rr_ints.size == 0:\n        return rr_ints\n    rr_ints = np.hstack((rr_ints[0], rr_ints))\n    return rr_ints\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.peaks.filter_peaks","title":"<code>filter_peaks(peaks, sample_rate=1000, min_rr=0.5, max_rr=20, min_delta=0.5)</code>","text":"<p>Filter out peaks with RR intervals outside of normal range.</p> <p>Parameters:</p> <ul> <li> <code>peaks</code>             (<code>array</code>)         \u2013          <p>Respiratory peaks.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>min_rr</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Minimum RR interval in seconds. Defaults to 0.5 s.</p> </li> <li> <code>max_rr</code>             (<code>float</code>, default:                 <code>20</code> )         \u2013          <p>Maximum RR interval in seconds. Defaults to 20 s.</p> </li> <li> <code>min_delta</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Minimum RR interval delta. Defaults to 0.5.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Filtered peaks.</p> </li> </ul> Source code in <code>physiokit/rsp/peaks.py</code> <pre><code>def filter_peaks(\n    peaks: npt.NDArray, sample_rate: float = 1000, min_rr: float = 0.5, max_rr: float = 20, min_delta: float = 0.5\n) -&gt; npt.NDArray:\n    \"\"\"Filter out peaks with RR intervals outside of normal range.\n\n    Args:\n        peaks (array): Respiratory peaks.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        min_rr (float, optional): Minimum RR interval in seconds. Defaults to 0.5 s.\n        max_rr (float, optional): Maximum RR interval in seconds. Defaults to 20 s.\n        min_delta (float, optional): Minimum RR interval delta. Defaults to 0.5.\n\n    Returns:\n        npt.NDArray: Filtered peaks.\n    \"\"\"\n    if peaks.size &lt;= 1:\n        return peaks\n    # Capture RR intervals\n    rr_ints = np.diff(peaks)\n    rr_ints = np.hstack((rr_ints[0], rr_ints))\n\n    # Filter out peaks with RR intervals outside of normal range\n    rr_mask = np.where((rr_ints &lt; min_rr * sample_rate) | (rr_ints &gt; max_rr * sample_rate), 1, 0)\n\n    # Filter out peaks that deviate more than delta\n    if min_delta is not None:\n        rr_mask = quotient_filter_mask(rr_ints, mask=rr_mask, lowcut=1 - min_delta, highcut=1 + min_delta)\n    filt_peaks = peaks[np.where(rr_mask == 0)[0]]\n    return filt_peaks\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.peaks.filter_rr_intervals","title":"<code>filter_rr_intervals(rr_ints, sample_rate=1000, min_rr=0.5, max_rr=20, min_delta=0.5)</code>","text":"<p>Filter out peaks with RR intervals outside of normal range.</p> <p>Parameters:</p> <ul> <li> <code>rr_ints</code>             (<code>array</code>)         \u2013          <p>RR intervals.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>min_rr</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Minimum RR interval in seconds. Defaults to 0.5 s.</p> </li> <li> <code>max_rr</code>             (<code>float</code>, default:                 <code>20</code> )         \u2013          <p>Maximum RR interval in seconds. Defaults to 20 s.</p> </li> <li> <code>min_delta</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Minimum RR interval delta. Defaults to 0.5.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Filtered RR intervals.</p> </li> </ul> Source code in <code>physiokit/rsp/peaks.py</code> <pre><code>def filter_rr_intervals(\n    rr_ints: npt.NDArray, sample_rate: float = 1000, min_rr: float = 0.5, max_rr: float = 20, min_delta: float = 0.5\n) -&gt; npt.NDArray:\n    \"\"\"Filter out peaks with RR intervals outside of normal range.\n\n    Args:\n        rr_ints (array): RR intervals.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        min_rr (float, optional): Minimum RR interval in seconds. Defaults to 0.5 s.\n        max_rr (float, optional): Maximum RR interval in seconds. Defaults to 20 s.\n        min_delta (float, optional): Minimum RR interval delta. Defaults to 0.5.\n\n    Returns:\n        npt.NDArray: Filtered RR intervals.\n    \"\"\"\n    if rr_ints.size == 0:\n        return np.array([])\n\n    # Filter out peaks with RR intervals outside of normal range\n    rr_mask = np.where((rr_ints &lt; min_rr * sample_rate) | (rr_ints &gt; max_rr * sample_rate), 1, 0)\n\n    # Filter out peaks that deviate more than delta\n    rr_mask = quotient_filter_mask(rr_ints, mask=rr_mask, lowcut=1 - min_delta, highcut=1 + min_delta)\n\n    return rr_mask\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.peaks.find_peaks","title":"<code>find_peaks(data, sample_rate=1000, peak_window=0.5, breath_window=2.0, breath_offset=0.05, peak_delay=0.3)</code>","text":"<p>Find peaks in RSP signal.</p> <p>Assumes input data is bandpass filtered with a lowcut of .05 Hz and a highcut of 3 Hz.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>RSP signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>peak_window</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Peak window in seconds. Defaults to 0.5 s.</p> </li> <li> <code>breath_window</code>             (<code>float</code>, default:                 <code>2.0</code> )         \u2013          <p>Breath window in seconds. Defaults to 2.0 s.</p> </li> <li> <code>breath_offset</code>             (<code>float</code>, default:                 <code>0.05</code> )         \u2013          <p>Breath offset in seconds. Defaults to 0.05 s.</p> </li> <li> <code>peak_delay</code>             (<code>float</code>, default:                 <code>0.3</code> )         \u2013          <p>Peak delay in seconds. Defaults to 0.3 s.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Peak locations.</p> </li> </ul> Source code in <code>physiokit/rsp/peaks.py</code> <pre><code>def find_peaks(\n    data: npt.NDArray,\n    sample_rate: float = 1000,\n    peak_window: float = 0.5,\n    breath_window: float = 2.0,\n    breath_offset: float = 0.05,\n    peak_delay: float = 0.3,\n) -&gt; npt.NDArray:\n    \"\"\"Find peaks in RSP signal.\n\n    Assumes input data is bandpass filtered with a lowcut of .05 Hz and a highcut of 3 Hz.\n\n    Args:\n        data (array): RSP signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        peak_window (float, optional): Peak window in seconds. Defaults to 0.5 s.\n        breath_window (float, optional): Breath window in seconds. Defaults to 2.0 s.\n        breath_offset (float, optional): Breath offset in seconds. Defaults to 0.05 s.\n        peak_delay (float, optional): Peak delay in seconds. Defaults to 0.3 s.\n\n    Returns:\n        npt.NDArray: Peak locations.\n    \"\"\"\n\n    # Clip negative values and square the signal\n    sqrd = np.where(data &gt; 0, data**2, 0)\n\n    # Apply 1st moving average filter\n    ma_peak_kernel = int(np.rint(peak_window * sample_rate))\n    ma_peak = spn.uniform_filter1d(sqrd, ma_peak_kernel, mode=\"nearest\")\n\n    # Apply 2nd moving average filter\n    ma_breath_kernel = int(np.rint(breath_window * sample_rate))\n    ma_breath = spn.uniform_filter1d(sqrd, ma_breath_kernel, mode=\"nearest\")\n\n    # Thresholds\n    min_height = ma_breath + breath_offset * np.mean(sqrd)\n    min_width = int(np.rint(peak_window * sample_rate))\n    min_delay = int(np.rint(peak_delay * sample_rate))\n\n    # Identify wave boundaries\n    waves = ma_peak &gt; min_height\n    beg_waves = np.where(np.logical_and(np.logical_not(waves[0:-1]), waves[1:]))[0]\n    end_waves = np.where(np.logical_and(waves[0:-1], np.logical_not(waves[1:])))[0]\n    end_waves = end_waves[end_waves &gt; beg_waves[0]]\n\n    # Identify peaks\n    peaks = []\n    for i in range(min(beg_waves.size, end_waves.size)):\n        beg, end = beg_waves[i], end_waves[i]\n        peak = beg + np.argmax(data[beg:end])\n        peak_width = end - beg\n        peak_delay = peak - peaks[-1] if peaks else min_delay\n\n        # Enforce minimum length and delay between peaks\n        if (peak_width &lt; min_width) or (peak_delay &lt; min_delay):\n            continue\n        peaks.append(peak)\n    # END FOR\n\n    return np.array(peaks, dtype=int)\n</code></pre>"},{"location":"api/rsp/#physiokit.rsp.synthesize","title":"<code>physiokit.rsp.synthesize</code>","text":""},{"location":"api/rsp/#physiokit.rsp.synthesize.synthesize","title":"<code>synthesize(signal_length=10000, sample_rate=1000, respiratory_rate=15)</code>","text":"<p>Generate synthetic respiratory signal using breathmetrics method.</p> <p>Utilize pk.signal.noise methods to make more realistic.</p> <p>Parameters:</p> <ul> <li> <code>signal_length</code>             (<code>int</code>, default:                 <code>10000</code> )         \u2013          <p>Signal length in samples. Defaults to 10000.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sample rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>respiratory_rate</code>             (<code>float</code>, default:                 <code>15</code> )         \u2013          <p>Respiratory rate in breaths per minute. Defaults to 15 bpm.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[NDArray, NDArray, NDArray]</code>         \u2013          <p>tuple[npt.NDArray, npt.NDArray, npt.NDArray]: Synthetic respiratory signal, segmentation mask, fiducial mask</p> </li> </ul> Source code in <code>physiokit/rsp/synthesize.py</code> <pre><code>def synthesize(\n    signal_length: int = 10000,\n    sample_rate: float = 1000,\n    respiratory_rate: float = 15,\n) -&gt; tuple[npt.NDArray, npt.NDArray, npt.NDArray]:\n    \"\"\"Generate synthetic respiratory signal using breathmetrics method.\n\n    Utilize pk.signal.noise methods to make more realistic.\n\n    Args:\n        signal_length (int, optional): Signal length in samples. Defaults to 10000.\n        sample_rate (float, optional): Sample rate in Hz. Defaults to 1000 Hz.\n        respiratory_rate (float, optional): Respiratory rate in breaths per minute. Defaults to 15 bpm.\n\n    Returns:\n        tuple[npt.NDArray, npt.NDArray, npt.NDArray]: Synthetic respiratory signal, segmentation mask, fiducial mask\n    \"\"\"\n\n    rsp, segs, fids = _simulate_breathmetrics_core(\n        signal_length=signal_length,\n        sample_rate=sample_rate,\n        breathing_rate=respiratory_rate / 60,\n        signal_noise=0,\n    )\n    return rsp, segs, fids\n</code></pre>"},{"location":"api/signal/","title":"Signal Processing","text":"<p>This submodule contains lots of underlying signal processing functionality used by the higher-level modules. This includes filtering routines, noise injection, and transformations.</p>"},{"location":"api/signal/#physiokit.signal.filter","title":"<code>physiokit.signal.filter</code>","text":""},{"location":"api/signal/#physiokit.signal.filter.filter_signal","title":"<code>filter_signal(data, lowcut=None, highcut=None, sample_rate=1000, order=2, axis=-1, forward_backward=True)</code>","text":"<p>Apply SOS filter to signal using butterworth design and cascaded filter.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>lowcut</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Lower cutoff in Hz. Defaults to None.</p> </li> <li> <code>highcut</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Upper cutoff in Hz. Defaults to None.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz Defaults to 1000 Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>2</code> )         \u2013          <p>Filter order. Defaults to 2.</p> </li> <li> <code>forward_backward</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Apply filter forward and backwards. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Filtered signal</p> </li> </ul> Source code in <code>physiokit/signal/filter.py</code> <pre><code>def filter_signal(\n    data: npt.NDArray,\n    lowcut: float | None = None,\n    highcut: float | None = None,\n    sample_rate: float = 1000,\n    order: int = 2,\n    axis: int = -1,\n    forward_backward: bool = True,\n) -&gt; npt.NDArray:\n    \"\"\"Apply SOS filter to signal using butterworth design and cascaded filter.\n\n    Args:\n        data (npt.NDArray): Signal\n        lowcut (float|None): Lower cutoff in Hz. Defaults to None.\n        highcut (float|None): Upper cutoff in Hz. Defaults to None.\n        sample_rate (float): Sampling rate in Hz Defaults to 1000 Hz.\n        order (int, optional): Filter order. Defaults to 2.\n        forward_backward (bool, optional): Apply filter forward and backwards. Defaults to True.\n\n    Returns:\n        npt.NDArray: Filtered signal\n    \"\"\"\n    sos = get_butter_sos(lowcut=lowcut, highcut=highcut, sample_rate=sample_rate, order=order)\n    if forward_backward:\n        return sps.sosfiltfilt(sos, data, axis=axis)\n    return sps.sosfilt(sos, data, axis=axis)\n</code></pre>"},{"location":"api/signal/#physiokit.signal.filter.generate_arm_biquad_sos","title":"<code>generate_arm_biquad_sos(lowcut, highcut, sample_rate, order=3, var_name='biquadFilter')</code>","text":"<p>Generate ARM CMSIS second order section coefficients.</p> <p>Parameters:</p> <ul> <li> <code>lowcut</code>             (<code>float</code>)         \u2013          <p>Lower cutoff in Hz.</p> </li> <li> <code>highcut</code>             (<code>float</code>)         \u2013          <p>Upper cutoff in Hz.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>)         \u2013          <p>Sampling rate in Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>Filter order. Defaults to 3.</p> </li> <li> <code>var_name</code>             (<code>str</code>, default:                 <code>'biquadFilter'</code> )         \u2013          <p>Variable name. Defaults to 'biquadFilter'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>ARM CMSIS second order section coefficients.</p> </li> </ul> Source code in <code>physiokit/signal/filter.py</code> <pre><code>def generate_arm_biquad_sos(\n    lowcut: float,\n    highcut: float,\n    sample_rate: float,\n    order: int = 3,\n    var_name: str = \"biquadFilter\",\n) -&gt; str:\n    \"\"\"Generate ARM CMSIS second order section coefficients.\n\n    Args:\n        lowcut (float): Lower cutoff in Hz.\n        highcut (float): Upper cutoff in Hz.\n        sample_rate (float): Sampling rate in Hz.\n        order (int, optional): Filter order. Defaults to 3.\n        var_name (str, optional): Variable name. Defaults to 'biquadFilter'.\n\n    Returns:\n        str: ARM CMSIS second order section coefficients.\n    \"\"\"\n    sos = get_butter_sos(lowcut=lowcut, highcut=highcut, sample_rate=sample_rate, order=order)\n    # Each section needs to be mapped as follows:\n    #   [b0, b1, b2, a0, a1, a2] -&gt; [b0, b1, b2, -a1, -a2]\n    sec_len_name = f\"{var_name.upper()}_NUM_SECS\"\n    arm_sos = sos[:, [0, 1, 2, 4, 5]] * [1, 1, 1, -1, -1]\n    coef_str = \", \".join(f\"{os.linesep:&lt;4}{c}\" if i % 5 == 0 else f\"{c}\" for i, c in enumerate(arm_sos.flatten()))\n    arm_str = (\n        f\"#define {sec_len_name} ({order:0d}){os.linesep}\"\n        f\"static float32_t {var_name}State[2 * {sec_len_name}];{os.linesep}\"\n        f\"static float32_t {var_name}[5 * {sec_len_name}] = {{ {coef_str}\\n}};{os.linesep}\"\n    )\n    return arm_str\n</code></pre>"},{"location":"api/signal/#physiokit.signal.filter.get_butter_sos","title":"<code>get_butter_sos(lowcut=None, highcut=None, sample_rate=1000, order=3)</code>  <code>cached</code>","text":"<p>Compute biquad filter coefficients as SOS. This function caches. For lowpass, lowcut is required and highcut is ignored. For highpass, highcut is required and lowcut is ignored. For bandpass, both lowcut and highcut are required.</p> <p>Parameters:</p> <ul> <li> <code>lowcut</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Lower cutoff in Hz. Defaults to None.</p> </li> <li> <code>highcut</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Upper cutoff in Hz. Defaults to None.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>order</code>             (<code>int</code>, default:                 <code>3</code> )         \u2013          <p>Filter order. Defaults to 3.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: SOS</p> </li> </ul> Source code in <code>physiokit/signal/filter.py</code> <pre><code>@functools.cache\ndef get_butter_sos(\n    lowcut: float | None = None,\n    highcut: float | None = None,\n    sample_rate: float = 1000,\n    order: int = 3,\n) -&gt; npt.NDArray:\n    \"\"\"Compute biquad filter coefficients as SOS. This function caches.\n    For lowpass, lowcut is required and highcut is ignored.\n    For highpass, highcut is required and lowcut is ignored.\n    For bandpass, both lowcut and highcut are required.\n\n    Args:\n        lowcut (float|None): Lower cutoff in Hz. Defaults to None.\n        highcut (float|None): Upper cutoff in Hz. Defaults to None.\n        sample_rate (float): Sampling rate in Hz. Defaults to 1000 Hz.\n        order (int, optional): Filter order. Defaults to 3.\n\n    Returns:\n        npt.NDArray: SOS\n    \"\"\"\n    nyq = sample_rate / 2\n    if lowcut is not None and highcut is not None:\n        freqs = [lowcut / nyq, highcut / nyq]\n        btype = \"bandpass\"\n    elif lowcut is not None:\n        freqs = lowcut / nyq\n        btype = \"highpass\"\n    elif highcut is not None:\n        freqs = highcut / nyq\n        btype = \"lowpass\"\n    else:\n        raise ValueError(\"At least one of lowcut or highcut must be specified\")\n    sos = sps.butter(order, freqs, btype=btype, output=\"sos\")\n    return sos\n</code></pre>"},{"location":"api/signal/#physiokit.signal.filter.moving_gradient_filter","title":"<code>moving_gradient_filter(data, sample_rate=1000, sig_window=0.1, avg_window=1.0, sig_prom_weight=1.5, mode='nearest', fval=0)</code>","text":"<p>Compute moving gradient filter to identify peaks in stream of data.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>Data stream.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>sig_window</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>Window size in seconds to compute signal gradient. Defaults to 0.1 s.</p> </li> <li> <code>avg_window</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Window size in seconds to compute average gradient. Defaults to 1.0 s.</p> </li> <li> <code>sig_prom_weight</code>             (<code>float</code>, default:                 <code>1.5</code> )         \u2013          <p>Weight to compute minimum signal height. Defaults to 1.5.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>array</code> (            <code>NDArray</code> )        \u2013          <p>Moving gradient filter.</p> </li> </ul> Source code in <code>physiokit/signal/filter.py</code> <pre><code>def moving_gradient_filter(\n    data: npt.NDArray,\n    sample_rate: float = 1000,\n    sig_window: float = 0.1,\n    avg_window: float = 1.0,\n    sig_prom_weight: float = 1.5,\n    mode: str = \"nearest\",\n    fval=0,\n) -&gt; npt.NDArray:\n    \"\"\"Compute moving gradient filter to identify peaks in stream of data.\n\n    Args:\n        data (array): Data stream.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        sig_window (float, optional): Window size in seconds to compute signal gradient. Defaults to 0.1 s.\n        avg_window (float, optional): Window size in seconds to compute average gradient. Defaults to 1.0 s.\n        sig_prom_weight (float, optional): Weight to compute minimum signal height. Defaults to 1.5.\n\n    Returns:\n        array: Moving gradient filter.\n    \"\"\"\n    # Compute gradient of signal and average.\n    abs_grad = np.abs(np.gradient(data))\n    sig_kernel = int(np.rint(sig_window * sample_rate))\n    avg_kernel = int(np.rint(avg_window * sample_rate))\n\n    # Smooth gradients\n    sig_grad = spn.uniform_filter1d(abs_grad, sig_kernel, mode=mode, cval=fval)\n    avg_grad = spn.uniform_filter1d(sig_grad, avg_kernel, mode=mode, cval=fval)\n\n    # Apply prominance weight\n    min_qrs_height = sig_prom_weight * avg_grad\n\n    # Remove baseline\n    rst = sig_grad - min_qrs_height\n    return rst\n</code></pre>"},{"location":"api/signal/#physiokit.signal.filter.normalize_signal","title":"<code>normalize_signal(data, eps=0.001, axis=-1)</code>","text":"<p>Normalize signal about its mean and std.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>eps</code>             (<code>float</code>, default:                 <code>0.001</code> )         \u2013          <p>Epsilon added to st. dev. Defaults to 1e-3.</p> </li> <li> <code>axis</code>             (<code>int</code>, default:                 <code>-1</code> )         \u2013          <p>Axis to normalize along. Defaults to -1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Normalized signal</p> </li> </ul> Source code in <code>physiokit/signal/filter.py</code> <pre><code>def normalize_signal(data: npt.NDArray, eps: float = 1e-3, axis: int = -1) -&gt; npt.NDArray:\n    \"\"\"Normalize signal about its mean and std.\n\n    Args:\n        data (npt.NDArray): Signal\n        eps (float, optional): Epsilon added to st. dev. Defaults to 1e-3.\n        axis (int, optional): Axis to normalize along. Defaults to -1.\n\n    Returns:\n        npt.NDArray: Normalized signal\n    \"\"\"\n    mu = np.nanmean(data, axis=axis)\n    std = np.nanstd(data, axis=axis) + eps\n    return (data - mu) / std\n</code></pre>"},{"location":"api/signal/#physiokit.signal.filter.quotient_filter_mask","title":"<code>quotient_filter_mask(data, mask=None, iterations=2, lowcut=0.8, highcut=1.2)</code>","text":"<p>Applies a quotient filter to identify outliers from list.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>mask</code>             (<code>NDArray | None</code>, default:                 <code>None</code> )         \u2013          <p>Rejection mask. Defaults to None.</p> </li> <li> <code>iterations</code>             (<code>int</code>, default:                 <code>2</code> )         \u2013          </li> <li> <code>lowcut</code>             (<code>float</code>, default:                 <code>0.8</code> )         \u2013          <p>Lower cutoff ratio. Defaults to 0.8.</p> </li> <li> <code>highcut</code>             (<code>float</code>, default:                 <code>1.2</code> )         \u2013          <p>Upper cutoff ratio. Defaults to 1.2.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Rejection mask 0=accept, 1=reject.</p> </li> </ul> Source code in <code>physiokit/signal/filter.py</code> <pre><code>def quotient_filter_mask(\n    data: npt.NDArray, mask: npt.NDArray | None = None, iterations: int = 2, lowcut: float = 0.8, highcut: float = 1.2\n) -&gt; npt.NDArray:\n    \"\"\"Applies a quotient filter to identify outliers from list.\n\n    Args:\n        data (npt.NDArray): Signal\n        mask (npt.NDArray | None, optional): Rejection mask. Defaults to None.\n        iterations (int, optional): # iterations to apply. Defaults to 2.\n        lowcut (float, optional): Lower cutoff ratio. Defaults to 0.8.\n        highcut (float, optional): Upper cutoff ratio. Defaults to 1.2.\n\n    Returns:\n        npt.NDArray: Rejection mask 0=accept, 1=reject.\n    \"\"\"\n\n    if mask is None:\n        mask = np.zeros_like(data, dtype=int)\n\n    for _ in range(iterations):\n        # Get indices of intervals to be filtered\n        filt_idxs = np.where(mask == 0)[0]\n        if filt_idxs.size &lt;= 1:\n            break\n        filt_ints = data[filt_idxs]\n        # Compute quotient of each interval with the next\n        filt_deltas = np.zeros(filt_ints.size)\n        filt_deltas[1:] = filt_ints[:-1] / filt_ints[1:]\n        filt_deltas[0] = filt_deltas[1]\n        # Get indices of intervals that are outside the range\n        delta_idxs = np.where((filt_deltas &lt; lowcut) | (filt_deltas &gt; highcut))[0]\n        # Update mask with rejected intervals\n        mask[filt_idxs[delta_idxs]] = 1\n        # Break if no intervals are rejected\n        if delta_idxs.size == 0:\n            break\n    # END FOR\n\n    return mask\n</code></pre>"},{"location":"api/signal/#physiokit.signal.filter.quotient_filter_mask--iterations-to-apply-defaults-to-2","title":"iterations to apply. Defaults to 2.","text":""},{"location":"api/signal/#physiokit.signal.filter.remove_baseline_wander","title":"<code>remove_baseline_wander(data, cutoff=0.05, quality=0.005, sample_rate=1000, axis=-1, forward_backward=True)</code>","text":"<p>Remove baseline wander from signal using a notch filter.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>cutoff</code>             (<code>float</code>, default:                 <code>0.05</code> )         \u2013          <p>Cutoff frequency in Hz. Defaults to 0.05.</p> </li> <li> <code>quality</code>             (<code>float</code>, default:                 <code>0.005</code> )         \u2013          <p>Quality factor. Defaults to 0.005.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>axis</code>             (<code>int</code>, default:                 <code>-1</code> )         \u2013          <p>Axis to filter along. Defaults to 0.</p> </li> <li> <code>forward_backward</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Apply filter forward and backwards. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Filtered signal</p> </li> </ul> Source code in <code>physiokit/signal/filter.py</code> <pre><code>def remove_baseline_wander(\n    data: npt.NDArray,\n    cutoff: float = 0.05,\n    quality: float = 0.005,\n    sample_rate: float = 1000,\n    axis: int = -1,\n    forward_backward: bool = True,\n) -&gt; npt.NDArray:\n    \"\"\"Remove baseline wander from signal using a notch filter.\n\n    Args:\n        data (npt.NDArray): Signal\n        cutoff (float, optional): Cutoff frequency in Hz. Defaults to 0.05.\n        quality (float, optional): Quality factor. Defaults to 0.005.\n        sample_rate (float): Sampling rate in Hz. Defaults to 1000 Hz.\n        axis (int, optional): Axis to filter along. Defaults to 0.\n        forward_backward (bool, optional): Apply filter forward and backwards. Defaults to True.\n\n    Returns:\n        npt.NDArray: Filtered signal\n    \"\"\"\n    b, a = sps.iirnotch(cutoff, Q=quality, fs=sample_rate)\n    if forward_backward:\n        return sps.filtfilt(b, a, data, axis=axis)\n    return sps.lfilter(b, a, data, axis=axis)\n</code></pre>"},{"location":"api/signal/#physiokit.signal.filter.resample_categorical","title":"<code>resample_categorical(data, sample_rate, target_rate, axis=0)</code>","text":"<p>Resample categorical data using nearest neighbor.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>sample_rate</code>             (<code>float</code>)         \u2013          <p>Signal sampling rate</p> </li> <li> <code>target_rate</code>             (<code>float</code>)         \u2013          <p>Target sampling rate</p> </li> <li> <code>axis</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Axis to resample along. Defaults to 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Resampled signal</p> </li> </ul> Source code in <code>physiokit/signal/filter.py</code> <pre><code>def resample_categorical(data: npt.NDArray, sample_rate: float, target_rate: float, axis: int = 0) -&gt; npt.NDArray:\n    \"\"\"Resample categorical data using nearest neighbor.\n\n    Args:\n        data (npt.NDArray): Signal\n        sample_rate (float): Signal sampling rate\n        target_rate (float): Target sampling rate\n        axis (int, optional): Axis to resample along. Defaults to 0.\n\n    Returns:\n        npt.NDArray: Resampled signal\n    \"\"\"\n    if sample_rate == target_rate:\n        return data\n    ratio = target_rate / sample_rate\n    actual_length = data.shape[axis]\n    target_length = int(np.round(data.shape[axis] * ratio))\n    interp_fn = spi.interp1d(np.arange(0, actual_length), data, kind=\"nearest\", axis=axis)\n    return interp_fn(np.arange(0, target_length)).astype(data.dtype)\n</code></pre>"},{"location":"api/signal/#physiokit.signal.filter.resample_signal","title":"<code>resample_signal(data, sample_rate=1000, target_rate=500, axis=-1)</code>","text":"<p>Resample signal using scipy FFT-based resample routine.</p> <p>NOTE: For very large signals, this may be slow. Consider using resample_poly instead.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Signal sampling rate. Defaults to 1000 Hz.</p> </li> <li> <code>target_rate</code>             (<code>float</code>, default:                 <code>500</code> )         \u2013          <p>Target sampling rate. Defaults to 500 Hz.</p> </li> <li> <code>axis</code>             (<code>int</code>, default:                 <code>-1</code> )         \u2013          <p>Axis to resample along. Defaults to -1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Resampled signal</p> </li> </ul> Source code in <code>physiokit/signal/filter.py</code> <pre><code>def resample_signal(\n    data: npt.NDArray, sample_rate: float = 1000, target_rate: float = 500, axis: int = -1\n) -&gt; npt.NDArray:\n    \"\"\"Resample signal using scipy FFT-based resample routine.\n\n    NOTE: For very large signals, this may be slow. Consider using resample_poly instead.\n\n    Args:\n        data (npt.NDArray): Signal\n        sample_rate (float): Signal sampling rate. Defaults to 1000 Hz.\n        target_rate (float): Target sampling rate. Defaults to 500 Hz.\n        axis (int, optional): Axis to resample along. Defaults to -1.\n\n    Returns:\n        npt.NDArray: Resampled signal\n    \"\"\"\n    desired_length = int(np.round(data.shape[axis] * target_rate / sample_rate))\n    return sps.resample(data, desired_length, axis=axis)\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise","title":"<code>physiokit.signal.noise</code>","text":"<p>Add various noise sources to signal.</p>"},{"location":"api/signal/#physiokit.signal.noise.add_baseline_wander","title":"<code>add_baseline_wander(data, amplitude=0.1, frequency=0.05, sample_rate=1000, signal_sd=None)</code>","text":"<p>Add baseline wander to signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>amplitude</code>             (<code>float</code>, default:                 <code>0.1</code> )         \u2013          <p>Amplitude in st dev. Defaults to 0.1.</p> </li> <li> <code>frequency</code>             (<code>float</code>, default:                 <code>0.05</code> )         \u2013          <p>Baseline wander frequency. Defaults to 0.05 Hz.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sample rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>signal_sd</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Signal standard deviation. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Signal w/ baseline wander</p> </li> </ul> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_baseline_wander(\n    data: npt.NDArray,\n    amplitude: float = 0.1,\n    frequency: float = 0.05,\n    sample_rate: float = 1000,\n    signal_sd: float | None = None,\n) -&gt; npt.NDArray:\n    \"\"\"Add baseline wander to signal.\n\n    Args:\n        data (npt.NDArray): Signal\n        amplitude (float, optional): Amplitude in st dev. Defaults to 0.1.\n        frequency (float, optional): Baseline wander frequency. Defaults to 0.05 Hz.\n        sample_rate (float, optional): Sample rate in Hz. Defaults to 1000 Hz.\n        signal_sd (float|None, optional): Signal standard deviation. Defaults to None.\n\n    Returns:\n        npt.NDArray: Signal w/ baseline wander\n    \"\"\"\n    if signal_sd is None:\n        signal_sd = np.nanstd(data)\n\n    return data + create_noise_distortions(\n        len(data),\n        signal_sd=signal_sd,\n        sample_rate=sample_rate,\n        frequencies=frequency,\n        amplitudes=amplitude,\n        noise_shapes=\"laplace\",\n    )\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise.add_burst_noise","title":"<code>add_burst_noise(data, amplitude=1, frequency=100, num_bursts=1, sample_rate=1000, signal_sd=None)</code>","text":"<p>Add high frequency burst noise to signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>amplitude</code>             (<code>float</code>, default:                 <code>1</code> )         \u2013          <p>Amplitude in st dev. Defaults to 1.</p> </li> <li> <code>frequency</code>             (<code>float</code>, default:                 <code>100</code> )         \u2013          <p>High frequency burst in Hz. Defaults to 100 Hz.</p> </li> <li> <code>num_bursts</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sample rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>signal_sd</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Signal standard deviation. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Signal w/ burst noise</p> </li> </ul> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_burst_noise(\n    data: npt.NDArray,\n    amplitude: float = 1,\n    frequency: float = 100,\n    num_bursts: int = 1,\n    sample_rate: float = 1000,\n    signal_sd: float | None = None,\n) -&gt; npt.NDArray:\n    \"\"\"Add high frequency burst noise to signal.\n\n    Args:\n        data (npt.NDArray): Signal\n        amplitude (float, optional): Amplitude in st dev. Defaults to 1.\n        frequency (float, optional): High frequency burst in Hz. Defaults to 100 Hz.\n        num_bursts (int, optional): # bursts to inject. Defaults to 1.\n        sample_rate (float, optional): Sample rate in Hz. Defaults to 1000 Hz.\n        signal_sd (float|None, optional): Signal standard deviation. Defaults to None.\n\n    Returns:\n        npt.NDArray: Signal w/ burst noise\n    \"\"\"\n\n    if signal_sd is None:\n        signal_sd = np.nanstd(data)\n    return data + create_noise_artifacts(\n        len(data),\n        signal_sd=signal_sd,\n        sample_rate=sample_rate,\n        frequency=frequency,\n        amplitude=amplitude,\n        num_artifacts=num_bursts,\n        min_artifact_percent=0.001,\n        max_artifact_percent=0.01,\n        artifacts_shape=\"laplace\",\n    )\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise.add_burst_noise--bursts-to-inject-defaults-to-1","title":"bursts to inject. Defaults to 1.","text":""},{"location":"api/signal/#physiokit.signal.noise.add_emg_noise","title":"<code>add_emg_noise(data, scale=1e-05, sample_rate=1000)</code>","text":"<p>Add EMG noise to signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>scale</code>             (<code>float</code>, default:                 <code>1e-05</code> )         \u2013          <p>Noise scale. Defaults to 1e-5.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Signal with EMG noise</p> </li> </ul> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_emg_noise(data: npt.NDArray, scale: float = 1e-5, sample_rate: float = 1000) -&gt; npt.NDArray:\n    \"\"\"Add EMG noise to signal.\n\n    Args:\n        data (npt.NDArray): Signal\n        scale (float, optional): Noise scale. Defaults to 1e-5.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000.\n\n    Returns:\n        npt.NDArray: Signal with EMG noise\n    \"\"\"\n    noise = np.tile(\n        np.sin(np.linspace(-0.5 * np.pi, 1.5 * np.pi, int(sample_rate)) * 10 * sample_rate),\n        int(np.ceil(data.size // sample_rate)),\n    )\n    return data + scale * noise[: data.size]\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise.add_lead_noise","title":"<code>add_lead_noise(data, scale=0.001)</code>","text":"<p>Add lead noise to signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>scale</code>             (<code>float</code>, default:                 <code>0.001</code> )         \u2013          <p>Noise scale. Defaults to 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Signal with lead noise</p> </li> </ul> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_lead_noise(data: npt.NDArray, scale: float = 1e-3) -&gt; npt.NDArray:\n    \"\"\"Add lead noise to signal.\n\n    Args:\n        data (npt.NDArray): Signal\n        scale (float, optional): Noise scale. Defaults to 1.\n\n    Returns:\n        npt.NDArray: Signal with lead noise\n    \"\"\"\n    return data + np.random.normal(0, scale, size=data.shape)\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise.add_motion_noise","title":"<code>add_motion_noise(data, amplitude=0.2, frequency=0.5, sample_rate=1000, signal_sd=None)</code>","text":"<p>Add motion noise to signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>amplitude</code>             (<code>float</code>, default:                 <code>0.2</code> )         \u2013          <p>Amplitude in st dev. Defaults to 0.2.</p> </li> <li> <code>frequency</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Motion frequency in Hz. Defaults to 0.5 Hz.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sample rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>signal_sd</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Signal standard deviation. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Signal w/ motion noise</p> </li> </ul> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_motion_noise(\n    data: npt.NDArray,\n    amplitude: float = 0.2,\n    frequency: float = 0.5,\n    sample_rate: float = 1000,\n    signal_sd: float | None = None,\n) -&gt; npt.NDArray:\n    \"\"\"Add motion noise to signal.\n\n    Args:\n        data (npt.NDArray): Signal\n        amplitude (float, optional): Amplitude in st dev. Defaults to 0.2.\n        frequency (float, optional): Motion frequency in Hz. Defaults to 0.5 Hz.\n        sample_rate (float, optional): Sample rate in Hz. Defaults to 1000 Hz.\n        signal_sd (float|None, optional): Signal standard deviation. Defaults to None.\n\n    Returns:\n        npt.NDArray: Signal w/ motion noise\n    \"\"\"\n    if signal_sd is None:\n        signal_sd = np.nanstd(data)\n\n    return data + create_noise_distortions(\n        len(data),\n        signal_sd=signal_sd,\n        sample_rate=sample_rate,\n        frequencies=frequency,\n        amplitudes=amplitude,\n        noise_shapes=\"laplace\",\n    )\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise.add_noise_sources","title":"<code>add_noise_sources(data, amplitudes, frequencies, noise_shapes, sample_rate=1000, signal_sd=None)</code>","text":"<p>Add multiple noise sources to signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>amplitudes</code>             (<code>list[float]</code>)         \u2013          <p>Amplitudes in st dev.</p> </li> <li> <code>frequencies</code>             (<code>list[float]</code>)         \u2013          <p>Frequencies in Hz.</p> </li> <li> <code>noise_shapes</code>             (<code>list[str]</code>)         \u2013          <p>Noise shapes.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sample rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>signal_sd</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Signal standard deviation. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Signal w/ noise</p> </li> </ul> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_noise_sources(\n    data: npt.NDArray,\n    amplitudes: list[float],\n    frequencies: list[float],\n    noise_shapes: list[str],\n    sample_rate: float = 1000,\n    signal_sd: float | None = None,\n) -&gt; npt.NDArray:\n    \"\"\"Add multiple noise sources to signal.\n\n    Args:\n        data (npt.NDArray): Signal\n        amplitudes (list[float]): Amplitudes in st dev.\n        frequencies (list[float]): Frequencies in Hz.\n        noise_shapes (list[str]): Noise shapes.\n        sample_rate (float, optional): Sample rate in Hz. Defaults to 1000 Hz.\n        signal_sd (float|None, optional): Signal standard deviation. Defaults to None.\n\n    Returns:\n        npt.NDArray: Signal w/ noise\n    \"\"\"\n    if signal_sd is None:\n        signal_sd = np.nanstd(data)\n\n    return data + create_noise_distortions(\n        len(data),\n        signal_sd=signal_sd,\n        sample_rate=sample_rate,\n        frequencies=frequencies,\n        amplitudes=amplitudes,\n        noise_shapes=noise_shapes,\n    )\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise.add_powerline_noise","title":"<code>add_powerline_noise(data, amplitude=0.01, frequency=50, sample_rate=1000, signal_sd=None)</code>","text":"<p>Add powerline noise to signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>amplitude</code>             (<code>float</code>, default:                 <code>0.01</code> )         \u2013          <p>Amplitude in st dev. Defaults to 0.01.</p> </li> <li> <code>frequency</code>             (<code>float</code>, default:                 <code>50</code> )         \u2013          <p>Powerline frequency in Hz. Defaults to 50 Hz.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sample rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>signal_sd</code>             (<code>float | None</code>, default:                 <code>None</code> )         \u2013          <p>Signal standard deviation. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Signal w/ powerline noise</p> </li> </ul> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_powerline_noise(\n    data: npt.NDArray,\n    amplitude: float = 0.01,\n    frequency: float = 50,\n    sample_rate: float = 1000,\n    signal_sd: float | None = None,\n) -&gt; npt.NDArray:\n    \"\"\"Add powerline noise to signal.\n\n    Args:\n        data (npt.NDArray): Signal\n        amplitude (float, optional): Amplitude in st dev. Defaults to 0.01.\n        frequency (float, optional): Powerline frequency in Hz. Defaults to 50 Hz.\n        sample_rate (float, optional): Sample rate in Hz. Defaults to 1000 Hz.\n        signal_sd (float|None, optional): Signal standard deviation. Defaults to None.\n\n    Returns:\n        npt.NDArray: Signal w/ powerline noise\n    \"\"\"\n    return data + create_powerline_noise(\n        len(data),\n        signal_sd=signal_sd,\n        sample_rate=sample_rate,\n        frequency=frequency,\n        amplitude=amplitude,\n    )\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise.add_random_scaling","title":"<code>add_random_scaling(data, lower=0.5, upper=2.0)</code>","text":"<p>Randomly scale signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>lower</code>             (<code>float</code>, default:                 <code>0.5</code> )         \u2013          <p>Lower bound. Defaults to 0.5.</p> </li> <li> <code>upper</code>             (<code>float</code>, default:                 <code>2.0</code> )         \u2013          <p>Upper bound. Defaults to 2.0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Signal with random scaling</p> </li> </ul> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_random_scaling(data: npt.NDArray, lower: float = 0.5, upper: float = 2.0) -&gt; npt.NDArray:\n    \"\"\"Randomly scale signal.\n\n    Args:\n        data (npt.NDArray): Signal\n        lower (float, optional): Lower bound. Defaults to 0.5.\n        upper (float, optional): Upper bound. Defaults to 2.0.\n\n    Returns:\n        npt.NDArray: Signal with random scaling\n    \"\"\"\n    return data * random.uniform(lower, upper)\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise.add_signal_attenuation","title":"<code>add_signal_attenuation()</code>","text":"<p>Add signal attenuation to signal.</p> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_signal_attenuation():\n    \"\"\"Add signal attenuation to signal.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise.add_signal_cutout","title":"<code>add_signal_cutout()</code>","text":"<p>Add cutout augmentation to signal.</p> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_signal_cutout():\n    \"\"\"Add cutout augmentation to signal.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/signal/#physiokit.signal.noise.add_signal_shift","title":"<code>add_signal_shift(data, shift_amount=0.1)</code>","text":"<p>Add signal shift augmentation to signal.</p> Source code in <code>physiokit/signal/noise.py</code> <pre><code>def add_signal_shift(data: npt.NDArray, shift_amount: float = 0.1):\n    \"\"\"Add signal shift augmentation to signal.\"\"\"\n    shift_idx = random.randint(0, data.size)\n    rst = data.copy()\n    rst[shift_idx:] += shift_amount\n    return rst\n</code></pre>"},{"location":"api/signal/#physiokit.signal.transform","title":"<code>physiokit.signal.transform</code>","text":""},{"location":"api/signal/#physiokit.signal.transform.compute_fft","title":"<code>compute_fft(data, sample_rate=1000, fft_len=None, window='blackman', axis=-1)</code>","text":"<p>Compute FFT of RSP signal.</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>array</code>)         \u2013          <p>RSP signal.</p> </li> <li> <code>sample_rate</code>             (<code>float</code>, default:                 <code>1000</code> )         \u2013          <p>Sampling rate in Hz. Defaults to 1000 Hz.</p> </li> <li> <code>fft_len</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>FFT length. Defaults to None.</p> </li> <li> <code>window</code>             (<code>str</code>, default:                 <code>'blackman'</code> )         \u2013          <p>Window to apply. Defaults to 'blackman'.</p> </li> <li> <code>axis</code>             (<code>int</code>, default:                 <code>-1</code> )         \u2013          <p>Axis to compute FFT. Defaults to -1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[NDArray, NDArray]</code>         \u2013          <p>tuple[array, array]: Frequencies and FFT of signal.</p> </li> </ul> Source code in <code>physiokit/signal/transform.py</code> <pre><code>def compute_fft(\n    data: npt.NDArray,\n    sample_rate: float = 1000,\n    fft_len: int | None = None,\n    window: str = \"blackman\",\n    axis: int = -1,\n) -&gt; tuple[npt.NDArray, npt.NDArray]:\n    \"\"\"Compute FFT of RSP signal.\n\n    Args:\n        data (array): RSP signal.\n        sample_rate (float, optional): Sampling rate in Hz. Defaults to 1000 Hz.\n        fft_len (int | None, optional): FFT length. Defaults to None.\n        window (str, optional): Window to apply. Defaults to 'blackman'.\n        axis (int, optional): Axis to compute FFT. Defaults to -1.\n\n    Returns:\n        tuple[array, array]: Frequencies and FFT of signal.\n    \"\"\"\n    data_len = data.shape[axis]\n    if fft_len is None:\n        fft_len = int(2 ** np.ceil(np.log2(data_len)))\n    if window == \"blackman\":\n        fft_win = np.blackman(data_len)\n        amp_corr = 1.93\n    else:\n        fft_win = np.ones(data_len)\n        amp_corr = 1.0\n    freqs = np.fft.fftfreq(fft_len, 1 / sample_rate)\n    sp = amp_corr * np.fft.fft(fft_win * data, fft_len, axis=axis) / data_len\n    return freqs, sp\n</code></pre>"},{"location":"api/signal/#physiokit.signal.transform.rescale_signal","title":"<code>rescale_signal(x, old_min, old_max, new_min, new_max, clip=True)</code>","text":"<p>Rescale signal to new range.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (<code>NDArray</code>)         \u2013          <p>Signal</p> </li> <li> <code>old_min</code>             (<code>float</code>)         \u2013          <p>Old minimum</p> </li> <li> <code>old_max</code>             (<code>float</code>)         \u2013          <p>Old maximum</p> </li> <li> <code>new_min</code>             (<code>float</code>)         \u2013          <p>New minimum</p> </li> <li> <code>new_max</code>             (<code>float</code>)         \u2013          <p>New maximum</p> </li> <li> <code>clip</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Clip values to range. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>         \u2013          <p>npt.NDArray: Rescaled signal</p> </li> </ul> Source code in <code>physiokit/signal/transform.py</code> <pre><code>def rescale_signal(\n    x: npt.NDArray, old_min: float, old_max: float, new_min: float, new_max: float, clip: bool = True\n) -&gt; npt.NDArray:\n    \"\"\"Rescale signal to new range.\n\n    Args:\n        x (npt.NDArray): Signal\n        old_min (float): Old minimum\n        old_max (float): Old maximum\n        new_min (float): New minimum\n        new_max (float): New maximum\n        clip (bool, optional): Clip values to range. Defaults to True.\n\n    Returns:\n        npt.NDArray: Rescaled signal\n    \"\"\"\n    if clip:\n        x = np.clip(x, old_min, old_max)\n    return (x - old_min) / (old_max - old_min) * (new_max - new_min) + new_min\n</code></pre>"},{"location":"signals/ecg/","title":"Electrocardiography (ECG)","text":"<p>Electrocardiography (ECG) is a non-invasive technique used to measure the electrical activity of the heart. ECG signals are often used to measure heart rate, heart rate variability (HRV), and respiratory rate. In PhysioKit, we provide a variety of routines for processing ECG signals.</p>"},{"location":"signals/ecg/#synthetic-ecg","title":"Synthetic ECG","text":"<p>PhysioKit provides a simple way to generate synthetic ECG signals using the <code>ecg.synthesize</code> function. By supplying only a handful of parameters, we can generate a fairly authentic ECG signal. PhysioKit also provides a more customizable way to generate synthetic ECG signals. Check out the Advanced Synthetic ECG section for more details.</p> Example <p>In the following snippet, we generate a synthetic ECG signal with a heart rate of 64 BPM sampled at 1000 Hz. This routine also returns segmenation and fiducial mask of landmark features (e.g P-wave).</p> <pre><code>import physiokit as pk\n\nsample_rate = 1000 # Hz\nheart_rate = 64 # BPM\nsignal_length = 8*sample_rate # 8 seconds\n\necg, segs, fids = pk.ecg.synthesize(\n    signal_length=signal_length,\n    sample_rate=sample_rate,\n    heart_rate=heart_rate,\n    leads=1,\n    preset=pk.ecg.EcgPreset.SR,\n    noise_multiplier=0.1\n)\n</code></pre> <p> </p>"},{"location":"signals/ecg/#noise-injection","title":"Noise Injection","text":"<p>Often real world ECG signals are corrupted by a variaty of noise sources. To generate a more realistic ECG signal, PhysioKit provides a number of noise injection routines such as baseline wander, powerline noise, and custom noise sources.</p> Example <p>Given the previous synthetic ECG signal, we can add baseline wander, powerline noise, and custom noise sources.</p> <pre><code># Add baseline wander\necg = pk.signal.add_baseline_wander(\n    data=ecg,\n    amplitude=1,\n    frequency=1,\n    sample_rate=sample_rate\n)\n\n# Add powerline noise\necg = pk.signal.add_powerline_noise(\n    data=ecg,\n    amplitude=0.05,\n    frequency=60,\n    sample_rate=sample_rate\n)\n\n# Add additional noise sources\necg = pk.signal.add_noise_sources(\n    data=ecg,\n    amplitudes=[0.05, 0.05],\n    frequencies=[60, 80],\n    noise_shapes=['laplace', 'laplace']\n    sample_rate=sample_rate\n)\necg = pk.signal.add_lead_noise(\n    data=ecg,\n    scale=5e-2\n)\n</code></pre> <p> </p>"},{"location":"signals/ecg/#sanitize-ecg","title":"Sanitize ECG","text":"<p>As mentioned above, ECG signals are often corrupted by noise and artifacts. The <code>ecg.clean</code> function provides a simple way to remove noise from ECG signals. By default, the routine implements a bandpass filter with cutoff frequencies of 0.5 and 40 Hz.</p> Example <p>In the following snippet, we apply a bandpass filter from 2 to 30 Hz to the synthetic ECG signal.</p> <pre><code>...\n\n# Using ECG signal from above ^\necg_clean = pk.ecg.clean(\n    data=ecg,\n    lowcut=1,\n    highcut=30,\n    order=5,\n    sample_rate=sample_rate\n)\n</code></pre> <p> </p>"},{"location":"signals/ecg/#extract-r-peaks-and-rr-intervals","title":"Extract R-Peaks and RR-Intervals","text":"<p>A common task in ECG processing is to extract R-peaks and RR-intervals. The <code>ecg.find_peaks</code> function implements a gradient-based peak detection algorithm to extract R-peaks from a given ECG signal. The <code>ecg.compute_rr_intervals</code> function can then be used to compute the corresponding RR-intervals from the R-peaks. Lastly, the <code>ecg.filter_rr_intervals</code> function removes RR-intervals that are too short or too long. This can often be due to artifacts such as noise or ectopic beats.</p> Example <p>Continuing from the previous example, we can extract R-peaks and RR-intervals from the cleaned ECG signal. We further create a mask to identify abnormal RR-intervals.</p> <pre><code>...\n\n# Extract R-peaks\npeaks = pk.ecg.find_peaks(data=ecg_clean, sample_rate=sample_rate)\n\n# Compute RR-intervals\nrri = pk.ecg.compute_rr_intervals(peaks=peaks)\n\n# Identify abnormal RR-intervals (e.g., ectopic beats)\n# Mask is a boolean array where 0 indicates a normal RR-interval\nmask = pk.ecg.filter_rr_intervals(rr_ints=rri, sample_rate=sample_rate)\n\n# Keep normal RR-intervals\npeaks_clean = peaks[mask == 0]\nrri_clean = rri[mask == 0]\n</code></pre> <p> </p>"},{"location":"signals/ecg/#compute-heart-rate","title":"Compute Heart Rate","text":"<p>The <code>ecg.compute_heart_rate</code> function computes the heart rate based on the selected <code>method</code>. Currently this is done based on the RR-intervals (<code>method=\"peak\"</code>). The function returns the heart rate in beats per minute (BPM) along with a \"quality of signal\" (QoS) metric. The QoS metric is a value between 0 and 1 where the higher the value, the higher the quality of the signal.</p> Example <pre><code># Compute heart rate\nhr_bpm, hr_qos = pk.ecg.compute_heart_rate(\n    ecg_clean,\n    method=\"peak\",\n    sample_rate=sample_rate\n)\n</code></pre> <p>OUTPUT:  Heart Rate: 64 BPM</p>"},{"location":"signals/ecg/#compute-hrv-metrics","title":"Compute HRV Metrics","text":"<p>Refer to HRV Documentation for computing HRV metrics based on RR-intervals.</p>"},{"location":"signals/ecg/#derive-respiratory-rate","title":"Derive Respiratory Rate","text":"<p>Respiratory sinus arrhythmia (RSA) is a phenomenon where the heart rate varies with respiration. Specifically, during inspiration, the heart rate increases and during expiration, the heart rate decreases. This is due to the parasympathetic nervous system which is responsible for slowing the heart rate. The <code>ecg.derive_respiratory_rate</code> function derives the respiratory rate based on the selected method. The default method (<code>rifv</code>) looks at frequency modulation of the RR intervals. The function returns the respiratory rate in breaths per minute (BPM) along with a \"quality of signal\" (QoS) metric.</p> Example <p>Once again, continuing from the previous example, we derive the respiratory rate from the ECG signal.</p> <p><pre><code>...\n\n# Compute respiratory rate using RIFV method\nrr_bpm, rr_qos = pk.ecg.derive_respiratory_rate(\n    peaks=peaks[mask == 0],\n    rri=rri[mask == 0],\n    method=\"rifv\",\n    sample_rate=sample_rate\n)\n</code></pre> OUTPUT:  Respiratory Rate: 16 BPM</p> <p>Note</p> <p>In certain conditions such as noisy environments, certain subjects, ECG lead position, etc., the respiratory rate may not be accurately estimated. In these cases, the QoS metric will be low.</p>"},{"location":"signals/ecg/#advanced-synthetic-ecg","title":"Advanced Synthetic ECG","text":"<p>PhysioKit provides a more customizable way to generate synthetic ECG signals. The <code>ecg.generate_nsr</code> and <code>ecg.generate_afib</code> functions in able generating normal sinus rhythm (NSR) and atrial fibrillation (AFib) ECG signals, respectively. In addition to returning the ECG signal, these advanced funtions also return the PQRST segmentations and fiducials. Both methods also allow tuning parameters such as cardiovasular presets (e.g. LBBB), p and t wave multipliers, signal impedance, and more.</p> Example <p>In the following example, we generate a single lead normal sinus rhythm ECG signal with a heart rate of 64 BPM sampled at 1000 Hz.</p> <pre><code>heart_rate = 64 # BPM\nsample_rate = 1000 # Hz\nsignal_length = 10*sample_rate # 10 seconds\n\n# Generate NSR synthetic ECG signal\necg, segs, fids = pk.ecg.synthesize(\n    signal_length=signal_length,\n    sample_rate=sample_rate,\n    heart_rate=heart_rate,\n    leads=1,\n    preset=pk.ecg.EcgPreset.SR,\n    p_multiplier=1.5,\n    t_multiplier=1.2,\n    noise_multiplier=0.2\n)\n</code></pre> <p> </p> Example <p>In the following example, we generate a single lead ECG signal containing atrial fibrillation (AFIB) with a heart rate of 64 BPM sampled at 1000 Hz.</p> <pre><code>heart_rate = 64 # BPM\nsample_rate = 1000 # Hz\nsignal_length = 10*sample_rate # 10 seconds\n\n# Generate NSR synthetic ECG signal\necg, segs, fids = pk.ecg.synthesize(\n    signal_length=signal_length,\n    sample_rate=sample_rate,\n    heart_rate=heart_rate,\n    leads=1,\n    preset=pk.ecg.EcgPreset.AFIB,\n    p_multiplier=1.5,\n    t_multiplier=1.2,\n    noise_multiplier=0.2\n)\n</code></pre> <p> </p>"},{"location":"signals/ecg/#ecg-segmentation","title":"ECG Segmentation","text":"<p>Coming soon...</p>"},{"location":"signals/ecg/#api","title":"API","text":"<p>Refer to ECG API for more details</p>"},{"location":"signals/hrv/","title":"Heart Rate Variability (HRV)","text":"<p>Heart rate variability (HRV) is the variation in the time interval between consecutive heartbeats. HRV is a measure of the autonomic nervous system (ANS) and is often used as a proxy for stress. HRV is also used to assess the risk of cardiovascular disease and sudden cardiac death.</p>"},{"location":"signals/hrv/#compute-time-domain-hrv","title":"Compute Time-Domain HRV","text":"<p>The <code>hrv.compute_hrv_time</code> function computes time-domain HRV metrics based on the supplied RR-intervals. The RR-intervals can be computed from ECG or PPG signals.</p> Metric Description mean_nn Mean of NN intervals sd_nn Standard deviation of NN intervals rms_sd Root mean square of successive differences sd_sd Standard deviation of successive differences cv_nn Coefficient of variation of NN intervals cv_sd Coefficient of variation of successive differences median_nn Median of NN intervals mad_nn Median absolute deviation of NN intervals mcv_nn Median coefficient of variation of NN intervals iqr_nn Interquartile range of NN intervals prc20_nn 20th percentile of NN intervals prc80_nn 80th percentile of NN intervals nn50 Number of pairs of successive NN intervals that differ by more than 50 ms nn20 Number of pairs of successive NN intervals that differ by more than 20 ms pnn50 Proportion of NN50 divided by total number of NN intervals pnn20 Proportion of NN20 divided by total number of NN intervals min_nn Minimum of NN intervals max_nn Maximum of NN intervals Example <p>In the following snippet, we generate a synthetic ECG signal, extract its r peaks and RR intervals, and finally compute time-domain HRV metrics.</p> <pre><code>tgt_hr = 64 # BPM\n\n# Generate synthetic ECG signal\necg = pk.ecg.synthesize(\n    duration=8,\n    sample_rate=fs,\n    heart_rate=tgt_hr,\n    leads=1\n)\n\n# Create timestamps\nts = np.arange(0, ecg.size) / fs\n\n# Clean ECG signal\necg_clean = pk.ecg.clean(\n    data=ecg_noise,\n    lowcut=2,\n    highcut=30,\n    order=5,\n    sample_rate=fs\n)\n\n# Extract R-peaks and RR-intervals\npeaks = pk.ecg.find_peaks(ecg_clean, sample_rate=fs)\nrri = pk.ecg.compute_rr_intervals(peaks)\nmask = pk.ecg.filter_rr_intervals(rri, sample_rate=fs)\n\n# Compute HRV metrics\nhrv_td = pk.hrv.compute_hrv_time(\n    rr_intervals=rri[mask == 0],\n    sample_rate=fs\n)\n</code></pre>"},{"location":"signals/hrv/#compute-frequency-domain-hrv","title":"Compute Frequency-Domain HRV","text":"<p>The <code>hrv.compute_hrv_frequency</code> function computes frequency-domain HRV metrics based on the supplied RR-intervals. The RR-intervals can be computed from ECG or PPG signals.</p> Example <p>Continuing from the previous example, we can also compute frequency-domain HRV metrics.</p> <pre><code>...\n\nbands = [(0.04, 0.15), (0.15, 0.4), (0.4, 0.5)]\nhrv_fd = pk.hrv.compute_hrv_frequency(\n    peaks[mask == 0], rri[mask == 0],\n    bands=bands,\n    sample_rate=fs\n)\n</code></pre> <p> </p>"},{"location":"signals/hrv/#api","title":"API","text":"<p>Refer to HRV API for more details</p>"},{"location":"signals/imu/","title":"IMU Processing","text":"<p>Inertial measurement units (IMUs) are electronic devices that measure and report a body's specific force (acceleration and angular velocity) and orientation (roll, pitch, and yaw). IMU signals are often used to measure activity, posture, and gait. In PhysioKit, we provide a variety of routines for processing IMU signals.</p>"},{"location":"signals/imu/#compute-enmo","title":"Compute ENMO","text":"<p>Euclidean Norm Minus One (ENMO) is a measure of activity intensity. ENMO is calculated as the square root of the sum of the squared acceleration values minus one. ENMO is often used to measure activity intensity from IMU signals.</p> Example <p>In the following example, we load accelerometer data from a user's wrist when performing the following sequence of tasks for 20s each: sitting, walking, and running.</p> <p> </p> <p>From this, we can then easily compute the ENMO:</p> <pre><code>import physiokit as pk\n\n# Load accelerometer data\nax, ay, az = ...\n\nenmo = pk.imu.compute_enmo(x=ax, y=ay, z=az)\n</code></pre> <p> </p>"},{"location":"signals/imu/#compute-tilt-angles","title":"Compute Tilt Angles","text":"<p>3-axis tilt provides insight into a user's orientation. For example, a 3-axis accelerometer placed on a user's wrist can be used to determine the its tilt. The z-angle of the wrist can be extremely useful for both fall and sleep detection applications.</p> Example <p>Following the previous example, we compute the tilt angles of the user's wrist.</p> <pre><code>import physiokit as pk\n\n# Load accelerometer data\nax, ay, az = ...\n\naax, aay, aaz = pk.imu.compute_tilt_angles(x=ax, y=ay, z=az)\n</code></pre> <p> </p>"},{"location":"signals/imu/#compute-counts","title":"Compute \"Counts\"","text":"<p>\"Counts\" is a measure of activity intensity and typically reported by actigraphy watches. Unfortunately, \"Counts\" is not a standardized measure and is calculated differently by different manufacturers. In PhysioKit, we compute counts based on algorithms reported by ActiGraph.</p> Example <p>Again, using the 3-axis accelerometer wrist data, we can compute \"counts\" as follows:</p> <pre><code>import physiokit as pk\n\n# Load accelerometer data\nax, ay, az = ...\n\ncounts = np.sum(pk.imu.compute_counts(\n    data=np.vstack((ax, ay, az)).T,\n    sample_rate=fs,\n    epoch_len=1\n), axis=1)\n</code></pre> <p> </p>"},{"location":"signals/imu/#api","title":"API","text":"<p>Refer to IMU API for more details</p>"},{"location":"signals/ppg/","title":"Photoplethysmography (PPG)","text":"<p>Photoplethysmography (PPG) is a non-invasive optical technique used to measure blood volume changes in the microvascular bed of tissue. PPG signals are often used to measure heart rate, heart rate variability (HRV), respiratory rate, and oxygen saturation (SpO2). In PhysioKit, we provide a variety of routines for processing PPG signals.</p>"},{"location":"signals/ppg/#synthetic-ppg","title":"Synthetic PPG","text":"<p>We can generate a synthetic PPG signal using the <code>ppg.synthesize</code> function. The function returns a numpy array with the PPG signal. The <code>duration</code> parameter specifies the length of the signal in seconds. The <code>sample_rate</code> parameter specifies the sampling rate in Hz. The <code>heart_rate</code> parameter specifies the heart rate in beats per minute (BPM).</p> Example <p>In the following snippet, we generate a synthetic PPG signal with a heart rate of 64 BPM sampled at 1000 Hz.</p> <pre><code>import physiokit as pk\n\nsample_rate = 1000  # Hz\nheart_rate = 64  # BPM\nsignal_length = 10*sample_rate # 10 seconds\n\nppg, segs, fids = pk.ppg.synthesize(\n    signal_length=signal_length,\n    sample_rate=sample_rate,\n    heart_rate=heart_rate,\n    frequency_modulation=0.3,\n    ibi_randomness=0.1\n)\n</code></pre> <p> </p>"},{"location":"signals/ppg/#noise-injection","title":"Noise Injection","text":"<p>We can additionally add noise to generate a more realistic PPG signal.</p> Example <p>Given the previous synthetic PPG signal, we can add baseline wander, powerline noise, and custom noise sources.</p> <pre><code># Add baseline wander\nppg_noise = pk.signal.add_baseline_wander(\n    data=ppg,\n    amplitude=1,\n    frequency=0.5,\n    sample_rate=sample_rate\n)\n\n# Add powerline noise\nppg_noise = pk.signal.add_powerline_noise(\n    data=ppg_noise,\n    amplitude=0.05,\n    frequency=60,\n    sample_rate=sample_rate\n)\n\n# Add additional noise sources\nppg_noise = pk.signal.add_noise_sources(\n    data=ppg_noise,\n    amplitudes=[0.05, 0.05],\n    frequencies=[10, 20],\n    noise_shapes=[\"laplace\", \"laplace\"],\n    sample_rate=sample_rate\n)\n</code></pre> <p> </p>"},{"location":"signals/ppg/#sanitize-ppg","title":"Sanitize PPG","text":"<p>PPG signals are often corrupted by noise. The <code>ppg.clean</code> function provides a simple way to remove noise from PPG signals. By default, the routine implements a bandpass filter with cutoff frequencies of 0.5 Hz and 4 Hz. The <code>lowcut</code> and <code>highcut</code> parameters can be used to specify the cutoff frequencies. The <code>order</code> parameter specifies the order of the filter. The <code>sample_rate</code> parameter specifies the sampling rate in Hz. The function returns a numpy array with the cleaned PPG signal.</p> Example <p>In the following snippet, we clean the noisy PPG signal using a bandpass filter with cutoff frequencies of 0.5 Hz and 4 Hz.</p> <pre><code>...\n\n# Clean PPG signal\nppg_clean = pk.ppg.clean(\n    data=ppg_noise,\n    lowcut=0.5,\n    highcut=4,\n    order=3,\n    sample_rate=sample_rate\n)\n</code></pre> <p> </p>"},{"location":"signals/ppg/#extract-r-peaks-and-rr-intervals","title":"Extract R-Peaks and RR-Intervals","text":"<p>A common task in PPG processing is to extract systolic peaks and peak-to-peak intervals. This has a 1:1 correspondance with r-peaks and therefore can be used to compute heart rate and HRV.</p> Example <p>In the following snippet, we extract systolic peaks and peak-to-peak intervals from the cleaned PPG signal.</p> <pre><code>...\n\n# Extract s-peaks\npeaks = pk.ppg.find_peaks(data=ppg_clean, sample_rate=sample_rate)\n\n# Compute peak-to-peak intervals\nrri = pk.ppg.compute_rr_intervals(peaks=peaks)\n\n# Identify abnormal RR-intervals (e.g., ectopic beats)\n# Mask is a boolean array where 0 indicates a normal RR-interval\nmask = pk.ppg.filter_rr_intervals(rr_ints=rri, sample_rate=sample_rate)\n\n# Keep normal RR-intervals\npeaks_clean = peaks[mask == 0]\nrri_clean = rri[mask == 0]\n</code></pre> <p> </p>"},{"location":"signals/ppg/#compute-heart-rate","title":"Compute Heart Rate","text":"<p>The <code>ppg.compute_heart_rate</code> function computes the heart rate based on the selected <code>method</code>. The <code>peak</code> method computes heart rate based on identified systolic peaks whereas <code>fft</code> method uses FFT to compute the heart rate. The function returns the heart rate in beats per minute (BPM) along with a \"quality of signal\" (QoS) metric. The QoS metric is a value between 0 and 1 where 1 indicates a high quality signal and 0 indicates a low quality signal. The QoS metric is based on the selected <code>method</code>.</p> Example <p>Continuing from the previous example, we can compute the heart rate using the <code>peak</code> method.</p> <pre><code># Compute heart rate using FFT\nhr_bpm, hr_qos = pk.ppg.compute_heart_rate(\n    ppg_clean,\n    method=\"fft\",\n    sample_rate=sample_rate\n)\n</code></pre> <p>OUTPUT:  Heart Rate: 64 BPM</p>"},{"location":"signals/ppg/#compute-hrv-metrics","title":"Compute HRV Metrics","text":"<p>Refer to HRV Documentation for computing HRV metrics based on systolic peaks.</p>"},{"location":"signals/ppg/#derive-respiratory-rate","title":"Derive Respiratory Rate","text":"<p>Respiratory sinus arrhythmia (RSA) is a phenomenon where the heart rate varies with respiration. Specifically, during inspiration, the heart rate increases and during expiration, the heart rate decreases. This is due to the parasympathetic nervous system which is responsible for slowing the heart rate. The <code>ppg.compute_respiratory_rate</code> function computes the respiratory rate based on the RR-intervals. The function returns the respiratory rate in breaths per minute (BPM) along with a \"quality of signal\" (QoS) metric. The QoS metric is a value between 0 and 1 where 1 indicates a high quality signal and 0 indicates a low quality signal. The QoS metric is based on the selected <code>method</code>. Beyond modulating the peak-to-peak intervals, respiration also modulates the amplitude of the PPG signal.</p> Example <p>In the following snippet, we derive the respiratory rate from the PPG signal.</p> <p><pre><code>...\n\n# Compute respiratory rate using RIFV method\nrr_bpm, rr_qos = pk.ppg.derive_respiratory_rate(\n    ppg=peaks[mask == 0],\n    peaks=peaks[mask == 0],\n    rri=rri[mask == 0],\n    method=\"rifv\",\n    sample_rate=sample_rate\n)\n</code></pre> OUTPUT:  Respiratory Rate: 18 BPM</p> Note <p>In certain conditions such as noisy environments, certain subjects, PPG position, etc., the respiratory rate may not be accurately estimated. In these cases, the QoS metric will be low.</p>"},{"location":"signals/ppg/#compute-spo2","title":"Compute SpO2","text":"<p>Using two PPG signals with different wavelengths, we can compute the oxygen saturation (SpO2). In PhysioKit, we can compute SpO2 in time domain using <code>ppg.compute_spo2_in_time</code> or frequency domain using <code>ppg.compute_spo2_in_frequency</code>.</p> Example <p>In the following snippet, we compute SpO2 in time and frequency domain from PPG signals captured by the MAX8614x sensor.</p> <p><pre><code>max8614x_coefs = [-16.666666, 8.333333, 100]\n\n# Load PPG signals\nppg_red = ...\nppg_ir = ...\n\n# NOTE: Pass the raw PPG signals as routines need to extract DC component\n\n# Compute SpO2 in time domain\nspo2_td = pk.ppg.compute_spo2_in_time(\n    ppg1=ppg_red,\n    ppg2=ppg_ir,\n    coefs=max8614x_coefs,\n    lowcut=0.5,\n    highcut=4,\n    sample_rate=sample_rate\n)\n\n# Compute SpO2 in frequency domain\nspo2_fd = pk.ppg.compute_spo2_in_frequency(\n    ppg1=ppg_red,\n    ppg2=ppg_ir,\n    coefs=max8614x_coefs,\n    lowcut=0.5,\n    highcut=4,\n    sample_rate=sample_rate\n)\n</code></pre> OUTPUT:  SpO2: 98%</p> <p>Note</p> <p>When calling <code>ppg.compute_spo2_in_time</code> or <code>ppg.compute_spo2_in_frequency</code>, the <code>coefs</code> parameter must be specified. The coefficients are used to convert the PPG signals to SpO2 via a 2nd order polynomial. The coefficients are specific to the PPG sensor and should be provided by the manufacturer.</p>"},{"location":"signals/ppg/#api","title":"API","text":"<p>Refer to PPG API for more details</p>"},{"location":"signals/rsp/","title":"Respiratory (RSP)","text":"<p>Respiratory rate is often measured on the chest using a respiration belt or a respiratory inductance plethysmography (RIP) sensor. PhysioKit provides a set of functions to process RSP signals. The functions can be used to generate synthetic RSP signals, clean noisy RSP signals, extract respiratory peaks, compute respiratory rate, and compute dual band metrics.</p>"},{"location":"signals/rsp/#synthetic-rsp","title":"Synthetic RSP","text":"<p>We can generate a synthetic RSP signal using the <code>rsp.synthesize</code> function. The function returns a numpy array with the RSP signal. The <code>duration</code> parameter specifies the length of the signal in seconds. The <code>sample_rate</code> parameter specifies the sampling rate in Hz. The <code>respiratory_rate</code> parameter specifies the respiratory rate in breaths per minute (BPM). The function returns a numpy array with the RSP signal.</p> Example <p>In the following snippet, we generate a synthetic RSP inductance band signal with a respiratory rate of 12 BPM sampled at 1000 Hz.</p> <pre><code>import physiokit as pk\n\nsample_rate = 1000 # Hz\nrespiratory_rate = 12 # BPM\n\nrsp, segs, fids = pk.rsp.synthesize(\n    signal_length=signal_length,\n    sample_rate=sample_rate,\n    respiratory_rate=respiratory_rate,\n)\n</code></pre> <p> </p>"},{"location":"signals/rsp/#noise-injection","title":"Noise Injection","text":"<p>We can additionally add noise to generate a more realistic RSP signal.</p> Example <p>Below adds baseline wander, powerline noise, and custom noise sources to the synthetic RSP signal.</p> <pre><code># Add baseline wander\nrsp_noise = pk.signal.add_baseline_wander(\n    data=rsp,\n    amplitude=2,\n    frequency=.05,\n    sample_rate=sample_rate\n)\n\n# Add powerline noise\nrsp_noise = pk.signal.add_powerline_noise(\n    data=rsp_noise,\n    amplitude=0.05,\n    frequency=60,\n    sample_rate=sample_rate\n)\n\n# Add additional noise sources\nrsp_noise = pk.signal.add_noise_sources(\n    data=rsp_noise,\n    amplitudes=[0.05, 0.05],\n    frequencies=[10, 20],\n    noise_shapes=[\"laplace\", \"laplace\"],\n    sample_rate=sample_rate\n)\n</code></pre> <p> </p>"},{"location":"signals/rsp/#sanitize-rsp","title":"Sanitize RSP","text":"<p>We can clean the RSP signal using the <code>rsp.clean</code> function. By default, the routine implements a bandpass filter with cutoff frequencies of 0.05 Hz and 3 Hz. The <code>lowcut</code> and <code>highcut</code> parameters can be used to specify the cutoff frequencies. The <code>order</code> parameter specifies the order of the filter. The <code>sample_rate</code> parameter specifies the sampling rate in Hz. The function returns a numpy array with the cleaned RSP signal.</p> Example <p>In the following snippet, we clean the noisy RSP signal using a bandpass filter with cutoff frequencies of 0.05 Hz and 3 Hz.</p> <pre><code>...\n\n# Clean RSP signal\nrsp_clean = pk.rsp.clean(\n    data=rsp_noise,\n    lowcut=0.05,\n    highcut=3,\n    order=3,\n    sample_rate=sample_rate\n)\n</code></pre> <p> </p>"},{"location":"signals/rsp/#extract-respiratory-peaks","title":"Extract Respiratory Peaks","text":"<p>A common task in RSP processing is to extract respiratory peaks. The <code>rsp.find_peaks</code> function implements a simple peak detection algorithm. The function returns a numpy array with the indices of the peaks.</p> Example <p>In the following snippet, we extract respiratory peaks from the cleaned RSP signal.</p> <pre><code>...\n\n# Extract respiratory cycles\npeaks = pk.rsp.find_peaks(data=rsp_clean, sample_rate=sample_rate)\n\n# Compute RR-intervals\nrri = pk.rsp.compute_rr_intervals(peaks=peaks)\n\n# Filter RR-intervals\nmask = pk.rsp.filter_rr_intervals(rr_ints=rri, sample_rate=sample_rate)\n\n# Keep normal RR-intervals\npeaks_clean = peaks[mask == 0]\nrri_clean = rri[mask == 0]\n</code></pre> <p> </p>"},{"location":"signals/rsp/#compute-respiratory-rate","title":"Compute Respiratory Rate","text":"<p>The <code>rsp.compute_respiratory_rate</code> function computes the respiratory rate in breaths per minute (BPM) based on the selected <code>method</code>. The <code>peak</code> method computes respiratory rate based on identified respiratory peaks whereas <code>fft</code> method uses FFT to compute the respiratory rate. The function returns the respiratory rate in breaths per minute (BPM) along with a \"quality of signal\" (QoS) metric. The QoS metric is based on the selected <code>method</code>.</p> Example <p>In the following snippet, we compute the respiratory rate based on the identified respiratory peaks.</p> <p><pre><code># Compute respiratory rate\nrr_bpm, rr_qos = pk.rsp.compute_respiratory_rate(\n    data=rsp_clean,\n    method=\"fft\",\n    sample_rate=sample_rate,\n    lowcut=0.05,\n    highcut=1\n)\n</code></pre> OUTPUT: Respiratory Rate: 12 BPM</p>"},{"location":"signals/rsp/#compute-dual-band-metrics","title":"Compute Dual Band Metrics","text":"<p>Using dual RIP bands, a ribcage (RC) band and a abdominal (AB) band, we can compute additional respiratory metrics. The <code>rsp.compute_dual_band_metrics</code> function computes the following metrics:</p> Metric Description rc_rr RC respiratory rate (BPM) ab_rr AB respiratory rate (BPM) vt_rr VT respiratory rate (BPM) phase Phase angle (degrees) lbi Labored breathing index rc_lead RC leads AB rc_percent Percent RC contribution qos Quality of signal (0-1) rc_pk_freq RC peak frequency (Hz) rc_pk_pwr RC peak power ab_pk_freq AB peak frequency (Hz) ab_pk_pwr AB peak power vt_pk_freq VT peak frequency (Hz) vt_pk_pwr VT peak power Example <p>In the following example, we generate synthetic RC and AB band data, compute the dual band metrics, and plot the results. We compute the metrics over a sliding window with a length of 10 seconds and an overlap of 1 second.</p> <pre><code>sample_rate = 1000\nrespiratory_rate = 12.2\nrc_amp = 1.5\nab_amp = 1.0\ndur_sec = 60\nwin_len = 10*sample_rate\novl_len = 1*sample_rate\n\n# Synthesize RC and AB band data\nrc = rc_amp*pk.rsp.synthesize(\n    duration=dur_sec,\n    sample_rate=sample_rate,\n    respiratory_rate=respiratory_rate\n)\nab = ab_amp*pk.rsp.synthesize(\n    duration=dur_sec,\n    sample_rate=sample_rate,\n    respiratory_rate=respiratory_rate\n)\n\n# Compute metrics over sliding window\nts_metrics, dual_metrics = [], []\nfor i in range(0, rc.size - win_len, ovl_len):\n    rc_win = rc[i:i+win_len]\n    ab_win = ab[i:i+win_len]\n    ts_metrics.append((i+win_len/2)/sample_rate)\n    dual_metrics.append(pk.rsp.compute_dual_band_metrics(\n        rc=rc_win,\n        ab=ab_win,\n        sample_rate=sample_rate,\n        pwr_threshold=0.9\n    ))\n</code></pre> <p> </p>"},{"location":"signals/rsp/#api","title":"API","text":"<p>Refer to RSP API for more details</p>"},{"location":"signals/signal/","title":"Signal Processing","text":"<p>The <code>signal</code> submodule contains lots of underlying signal processing functionality used by the higher-level modules. This includes filtering routines, noise injection, and transformations.</p>"},{"location":"signals/signal/#filtering","title":"Filtering","text":"<p><code>signal.filter</code> contains a number of filtering routines such as a generic second order section biquad filter, resampling, normalizing, smoothing, and more. Below we highlight a few of these routines.</p> Function Description pk.signal.resample_signal Resamples a signal to a new sampling rate. pk.signal.resample_categorical Resamples a categorical signal to a new sampling rate. pk.signal.normalize_signal Normalizes a signal to a new range. pk.signal.filter_signal Filters a signal using a second order section biquad filter. pk.signal.remove_baseline_wander Removes baseline wander from a signal. pk.signal.smooth_signal Smooths a signal using a Savitzky-Golay filter. pk.signal.quotient_filter_mask Applies a quotient filter to identify outliers from list. Example <p>In the following snippet, we generate a synthetic PPG signal with a heart rate of 64 BPM sampled at 1000 Hz. We then filter the signal using a second order section biquad filter.</p> <pre><code>import physiokit as pk\n\nfs = 1000  # Hz\ntgt_hr = 64  # BPM\n\nppg = pk.ppg.synthesize(\n    duration=10,  # in seconds\n    sample_rate=fs,\n    heart_rate=tgt_hr,\n)\n\nppg_clean = pk.signal.filter_signal(\n    data=ppg_noise,\n    lowcut=0.5,\n    highcut=4,\n    order=3,\n    sample_rate=fs\n    forward_backward=True\n)\n</code></pre> <p> </p>"},{"location":"signals/signal/#noise-injection","title":"Noise Injection","text":"<p><code>signal.noise</code> contains a number of noise injection routines such as Gaussian noise, uniform noise, and more. Below we highlight a few of these routines.</p> Function Description pk.signal.add_baseline_wander Adds baseline wander to a signal. pk.signal.add_motion_noise Adds motion noise to a signal. pk.signal.add_burst_noise Adds burst noise to a signal. pk.signal.add_powerline_noise Adds powerline noise to a signal. pk.signal.add_noise_sources Adds additional noise sources to a signal. Example <p>In the following snippet, we generate a synthetic PPG signal and inject the following noises: baseline wander, powerline noise, and custom noise sources.</p> <pre><code>import physiokit as pk\n\nfs = 1000  # Hz\ntgt_hr = 64  # BPM\n\nppg = pk.ppg.synthesize(\n    duration=10,  # in seconds\n    sample_rate=fs,\n    heart_rate=tgt_hr,\n)\n\n# Add baseline wander\nppg_noise = pk.signal.add_baseline_wander(\n    data=ppg,\n    amplitude=2,\n    frequency=1,\n    sample_rate=fs\n)\n\n# Add powerline noise\nppg_noise = pk.signal.add_powerline_noise(\n    data=ppg_noise,\n    amplitude=0.05,\n    frequency=60,\n    sample_rate=fs\n)\n\n# Add additional noise sources\nppg_noise = pk.signal.add_noise_sources(\n    data=ppg_noise,\n    amplitudes=[0.05, 0.05],\n    frequencies=[10, 20],\n    sample_rate=fs\n)\n</code></pre> <p> </p>"},{"location":"signals/signal/#transformations","title":"Transformations","text":"<p><code>signal.transform</code> contains a number of transformation routines such as the fast Fourier transform, the inverse fast Fourier transform, and more. Below we highlight a few of these routines.</p>"},{"location":"signals/signal/#api","title":"API","text":"<p>Refer to signal API for more details</p>"},{"location":"tutorial/quickstart/","title":"Quick Start","text":""},{"location":"tutorial/quickstart/#installation","title":"Installation","text":"<p>Currently, the package is available on PyPI as a universal wheel for Python 3.11+. Installing PhysioKit can be done using <code>Poetry</code> or <code>pip</code>.</p> via Poetryvia pip <p><pre><code>$ poetry add physiokit\n\n---&gt; 100%\n</code></pre> </p> <p><pre><code>$ pip install physiokit\n\n---&gt; 100%\n</code></pre> </p> Example <p>In this example, we will generate a synthetic ECG signal, clean it, and compute heart rate and HRV metrics.</p> <pre><code>import physiokit as pk\n\nsample_rate = 1000 # Hz\nheart_rate = 64 # BPM\nsignal_length = 8*sample_rate # 8 seconds\n\n# Generate synthetic ECG signal\necg, segs, fids = pk.ecg.synthesize(\n    signal_length=signal_length,\n    sample_rate=sample_rate,\n    heart_rate=heart_rate,\n    leads=1\n)\necg = ecg.squeeze()\n\n# Clean ECG signal\necg_clean = pk.ecg.clean(ecg, sample_rate=sample_rate)\n\n# Compute heart rate\nhr_bpm, _ = pk.ecg.compute_heart_rate(ecg_clean, sample_rate=sample_rate)\n\n# Extract R-peaks and RR-intervals\npeaks = pk.ecg.find_peaks(ecg_clean, sample_rate=sample_rate)\nrri = pk.ecg.compute_rr_intervals(peaks)\nmask = pk.ecg.filter_rr_intervals(rri, sample_rate=sample_rate)\n\n# Re-compute heart rate\nhr_bpm = 60 / (np.nanmean(rri[mask == 0]) / sample_rate)\n\n# Compute HRV metrics\nhrv_td = pk.hrv.compute_hrv_time(rri[mask == 0], sample_rate=sample_rate)\n\nbands = [(0.04, 0.15), (0.15, 0.4), (0.4, 0.5)]\nhrv_fd = pk.hrv.compute_hrv_frequency(\n    peaks[mask == 0],\n    rri[mask == 0],\n    bands=bands,\n    sample_rate=sample_rate\n)\n</code></pre>"}]}